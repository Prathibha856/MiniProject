{"ast":null,"code":"'use strict';\n\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/classPrivateFieldLooseKey\";\nimport { validateTransform } from '../../../src/private/animated/NativeAnimatedValidation';\nimport NativeAnimatedHelper from '../../../src/private/animated/NativeAnimatedHelper';\nimport AnimatedNode from './AnimatedNode';\nimport AnimatedWithChildren from './AnimatedWithChildren';\nvar _shallowNodes = _classPrivateFieldLooseKey(\"shallowNodes\");\nexport default class AnimatedTransform extends AnimatedWithChildren {\n  constructor(transforms) {\n    super();\n    Object.defineProperty(this, _shallowNodes, {\n      writable: true,\n      value: void 0\n    });\n    this._transforms = void 0;\n    this._transforms = transforms;\n    const shallowNodes = [];\n    if (Array.isArray(transforms)) {\n      for (let ii = 0, length = transforms.length; ii < length; ii++) {\n        const transform = transforms[ii];\n        for (const key in transform) {\n          const value = transform[key];\n          if (value instanceof AnimatedNode) {\n            shallowNodes.push(value);\n          }\n        }\n      }\n    }\n    _classPrivateFieldLooseBase(this, _shallowNodes)[_shallowNodes] = shallowNodes;\n  }\n  __makeNative(platformConfig) {\n    const nodes = _classPrivateFieldLooseBase(this, _shallowNodes)[_shallowNodes];\n    for (let ii = 0, length = nodes.length; ii < length; ii++) {\n      const node = nodes[ii];\n      node.__makeNative(platformConfig);\n    }\n    super.__makeNative(platformConfig);\n  }\n  __getValue() {\n    return mapTransforms(this._transforms, animatedNode => animatedNode.__getValue());\n  }\n  __getAnimatedValue() {\n    return mapTransforms(this._transforms, animatedNode => animatedNode.__getAnimatedValue());\n  }\n  __attach() {\n    const nodes = _classPrivateFieldLooseBase(this, _shallowNodes)[_shallowNodes];\n    for (let ii = 0, length = nodes.length; ii < length; ii++) {\n      const node = nodes[ii];\n      node.__addChild(this);\n    }\n  }\n  __detach() {\n    const nodes = _classPrivateFieldLooseBase(this, _shallowNodes)[_shallowNodes];\n    for (let ii = 0, length = nodes.length; ii < length; ii++) {\n      const node = nodes[ii];\n      node.__removeChild(this);\n    }\n    super.__detach();\n  }\n  __getNativeConfig() {\n    const transformsConfig = [];\n    const transforms = this._transforms;\n    for (let ii = 0, length = transforms.length; ii < length; ii++) {\n      const transform = transforms[ii];\n      for (const key in transform) {\n        const value = transform[key];\n        if (value instanceof AnimatedNode) {\n          transformsConfig.push({\n            type: 'animated',\n            property: key,\n            nodeTag: value.__getNativeTag()\n          });\n        } else {\n          transformsConfig.push({\n            type: 'static',\n            property: key,\n            value: NativeAnimatedHelper.transformDataType(value)\n          });\n        }\n      }\n    }\n    if (__DEV__) {\n      validateTransform(transformsConfig);\n    }\n    return {\n      type: 'transform',\n      transforms: transformsConfig\n    };\n  }\n}\nfunction mapTransforms(transforms, mapFunction) {\n  return transforms.map(transform => {\n    const result = {};\n    for (const key in transform) {\n      const value = transform[key];\n      if (value instanceof AnimatedNode) {\n        result[key] = mapFunction(value);\n      } else if (Array.isArray(value)) {\n        result[key] = value.map(element => element instanceof AnimatedNode ? mapFunction(element) : element);\n      } else if (typeof value === 'object') {\n        const object = {};\n        for (const propertyName in value) {\n          const propertyValue = value[propertyName];\n          object[propertyName] = propertyValue instanceof AnimatedNode ? mapFunction(propertyValue) : propertyValue;\n        }\n        result[key] = object;\n      } else {\n        result[key] = value;\n      }\n    }\n    return result;\n  });\n}","map":{"version":3,"names":["_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","validateTransform","NativeAnimatedHelper","AnimatedNode","AnimatedWithChildren","_shallowNodes","AnimatedTransform","constructor","transforms","Object","defineProperty","writable","value","_transforms","shallowNodes","Array","isArray","ii","length","transform","key","push","__makeNative","platformConfig","nodes","node","__getValue","mapTransforms","animatedNode","__getAnimatedValue","__attach","__addChild","__detach","__removeChild","__getNativeConfig","transformsConfig","type","property","nodeTag","__getNativeTag","transformDataType","__DEV__","mapFunction","map","result","element","object","propertyName","propertyValue"],"sources":["F:/MiniProject/node_modules/react-native/Libraries/Animated/nodes/AnimatedTransform.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport type {PlatformConfig} from '../AnimatedPlatformConfig';\n\nimport {validateTransform} from '../../../src/private/animated/NativeAnimatedValidation';\nimport NativeAnimatedHelper from '../../../src/private/animated/NativeAnimatedHelper';\nimport AnimatedNode from './AnimatedNode';\nimport AnimatedWithChildren from './AnimatedWithChildren';\n\ntype Transform<T = AnimatedNode> = {\n  [string]:\n    | number\n    | string\n    | T\n    | $ReadOnlyArray<number | string | T>\n    | {[string]: number | string | T},\n};\n\nexport default class AnimatedTransform extends AnimatedWithChildren {\n  // NOTE: For potentially historical reasons, some operations only operate on\n  // the first level of AnimatedNode instances. This optimizes that bevavior.\n  #shallowNodes: $ReadOnlyArray<AnimatedNode>;\n\n  _transforms: $ReadOnlyArray<Transform<>>;\n\n  constructor(transforms: $ReadOnlyArray<Transform<>>) {\n    super();\n    this._transforms = transforms;\n\n    const shallowNodes = [];\n    // NOTE: This check should not be necessary, but the types are not enforced\n    // as of this writing. This check should be hoisted to instantiation sites.\n    if (Array.isArray(transforms)) {\n      for (let ii = 0, length = transforms.length; ii < length; ii++) {\n        const transform = transforms[ii];\n        // There should be exactly one property in `transform`.\n        for (const key in transform) {\n          const value = transform[key];\n          if (value instanceof AnimatedNode) {\n            shallowNodes.push(value);\n          }\n        }\n      }\n    }\n    this.#shallowNodes = shallowNodes;\n  }\n\n  __makeNative(platformConfig: ?PlatformConfig) {\n    const nodes = this.#shallowNodes;\n    for (let ii = 0, length = nodes.length; ii < length; ii++) {\n      const node = nodes[ii];\n      node.__makeNative(platformConfig);\n    }\n    super.__makeNative(platformConfig);\n  }\n\n  __getValue(): $ReadOnlyArray<Transform<any>> {\n    return mapTransforms(this._transforms, animatedNode =>\n      animatedNode.__getValue(),\n    );\n  }\n\n  __getAnimatedValue(): $ReadOnlyArray<Transform<any>> {\n    return mapTransforms(this._transforms, animatedNode =>\n      animatedNode.__getAnimatedValue(),\n    );\n  }\n\n  __attach(): void {\n    const nodes = this.#shallowNodes;\n    for (let ii = 0, length = nodes.length; ii < length; ii++) {\n      const node = nodes[ii];\n      node.__addChild(this);\n    }\n  }\n\n  __detach(): void {\n    const nodes = this.#shallowNodes;\n    for (let ii = 0, length = nodes.length; ii < length; ii++) {\n      const node = nodes[ii];\n      node.__removeChild(this);\n    }\n    super.__detach();\n  }\n\n  __getNativeConfig(): any {\n    const transformsConfig: Array<any> = [];\n\n    const transforms = this._transforms;\n    for (let ii = 0, length = transforms.length; ii < length; ii++) {\n      const transform = transforms[ii];\n      // There should be exactly one property in `transform`.\n      for (const key in transform) {\n        const value = transform[key];\n        if (value instanceof AnimatedNode) {\n          transformsConfig.push({\n            type: 'animated',\n            property: key,\n            nodeTag: value.__getNativeTag(),\n          });\n        } else {\n          transformsConfig.push({\n            type: 'static',\n            property: key,\n            /* $FlowFixMe[incompatible-call] - `value` can be an array or an\n               object. This is not currently handled by `transformDataType`.\n               Migrating to `TransformObject` might solve this. */\n            value: NativeAnimatedHelper.transformDataType(value),\n          });\n        }\n      }\n    }\n\n    if (__DEV__) {\n      validateTransform(transformsConfig);\n    }\n    return {\n      type: 'transform',\n      transforms: transformsConfig,\n    };\n  }\n}\n\nfunction mapTransforms<T>(\n  transforms: $ReadOnlyArray<Transform<>>,\n  mapFunction: AnimatedNode => T,\n): $ReadOnlyArray<Transform<T>> {\n  return transforms.map(transform => {\n    const result: Transform<T> = {};\n    // There should be exactly one property in `transform`.\n    for (const key in transform) {\n      const value = transform[key];\n      if (value instanceof AnimatedNode) {\n        result[key] = mapFunction(value);\n      } else if (Array.isArray(value)) {\n        result[key] = value.map(element =>\n          element instanceof AnimatedNode ? mapFunction(element) : element,\n        );\n      } else if (typeof value === 'object') {\n        const object: {[string]: number | string | T} = {};\n        for (const propertyName in value) {\n          const propertyValue = value[propertyName];\n          object[propertyName] =\n            propertyValue instanceof AnimatedNode\n              ? mapFunction(propertyValue)\n              : propertyValue;\n        }\n        result[key] = object;\n      } else {\n        result[key] = value;\n      }\n    }\n    return result;\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}