{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nconst _excluded = [\"onContentSizeChange\"];\nvar _jsxFileName = \"F:\\\\MiniProject\\\\node_modules\\\\@react-native\\\\virtualized-lists\\\\Lists\\\\VirtualizedList.js\";\nimport Batchinator from '../Interaction/Batchinator';\nimport clamp from '../Utilities/clamp';\nimport infoLog from '../Utilities/infoLog';\nimport { CellRenderMask } from './CellRenderMask';\nimport ChildListCollection from './ChildListCollection';\nimport FillRateHelper from './FillRateHelper';\nimport ListMetricsAggregator from './ListMetricsAggregator';\nimport StateSafePureComponent from './StateSafePureComponent';\nimport ViewabilityHelper from './ViewabilityHelper';\nimport CellRenderer from './VirtualizedListCellRenderer';\nimport { VirtualizedListCellContextProvider, VirtualizedListContext, VirtualizedListContextProvider } from './VirtualizedListContext.js';\nimport { horizontalOrDefault, initialNumToRenderOrDefault, maxToRenderPerBatchOrDefault, onEndReachedThresholdOrDefault, onStartReachedThresholdOrDefault, windowSizeOrDefault } from './VirtualizedListProps';\nimport { computeWindowedRenderLimits, keyExtractor as defaultKeyExtractor } from './VirtualizeUtils';\nimport invariant from 'invariant';\nimport nullthrows from 'nullthrows';\nimport * as React from 'react';\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport RefreshControl from \"react-native-web/dist/exports/RefreshControl\";\nimport ScrollView from \"react-native-web/dist/exports/ScrollView\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ON_EDGE_REACHED_EPSILON = 0.001;\nlet _usedIndexForKey = false;\nlet _keylessItemComponentName = '';\nfunction getScrollingThreshold(threshold, visibleLength) {\n  return threshold * visibleLength / 2;\n}\nclass VirtualizedList extends StateSafePureComponent {\n  scrollToEnd(params) {\n    const animated = params ? params.animated : true;\n    const veryLast = this.props.getItemCount(this.props.data) - 1;\n    if (veryLast < 0) {\n      return;\n    }\n    const frame = this._listMetrics.getCellMetricsApprox(veryLast, this.props);\n    const offset = Math.max(0, frame.offset + frame.length + this._footerLength - this._scrollMetrics.visibleLength);\n    this.scrollToOffset({\n      animated,\n      offset\n    });\n  }\n  scrollToIndex(params) {\n    const {\n      data,\n      getItemCount,\n      getItemLayout,\n      onScrollToIndexFailed\n    } = this.props;\n    const {\n      animated,\n      index,\n      viewOffset,\n      viewPosition\n    } = params;\n    invariant(index >= 0, `scrollToIndex out of range: requested index ${index} but minimum is 0`);\n    invariant(getItemCount(data) >= 1, `scrollToIndex out of range: item length ${getItemCount(data)} but minimum is 1`);\n    invariant(index < getItemCount(data), `scrollToIndex out of range: requested index ${index} is out of 0 to ${getItemCount(data) - 1}`);\n    if (!getItemLayout && index > this._listMetrics.getHighestMeasuredCellIndex()) {\n      invariant(!!onScrollToIndexFailed, 'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' + 'otherwise there is no way to know the location of offscreen indices or handle failures.');\n      onScrollToIndexFailed({\n        averageItemLength: this._listMetrics.getAverageCellLength(),\n        highestMeasuredFrameIndex: this._listMetrics.getHighestMeasuredCellIndex(),\n        index\n      });\n      return;\n    }\n    const frame = this._listMetrics.getCellMetricsApprox(Math.floor(index), this.props);\n    const offset = Math.max(0, this._listMetrics.getCellOffsetApprox(index, this.props) - (viewPosition || 0) * (this._scrollMetrics.visibleLength - frame.length)) - (viewOffset || 0);\n    this.scrollToOffset({\n      offset,\n      animated\n    });\n  }\n  scrollToItem(params) {\n    const {\n      item\n    } = params;\n    const {\n      data,\n      getItem,\n      getItemCount\n    } = this.props;\n    const itemCount = getItemCount(data);\n    for (let index = 0; index < itemCount; index++) {\n      if (getItem(data, index) === item) {\n        this.scrollToIndex(Object.assign({}, params, {\n          index\n        }));\n        break;\n      }\n    }\n  }\n  scrollToOffset(params) {\n    const {\n      animated,\n      offset\n    } = params;\n    const scrollRef = this._scrollRef;\n    if (scrollRef == null) {\n      return;\n    }\n    if (scrollRef.scrollTo == null) {\n      console.warn('No scrollTo method provided. This may be because you have two nested ' + 'VirtualizedLists with the same orientation, or because you are ' + 'using a custom component that does not implement scrollTo.');\n      return;\n    }\n    const {\n      horizontal,\n      rtl\n    } = this._orientation();\n    if (horizontal && rtl && !this._listMetrics.hasContentLength()) {\n      console.warn('scrollToOffset may not be called in RTL before content is laid out');\n      return;\n    }\n    scrollRef.scrollTo(Object.assign({\n      animated\n    }, this._scrollToParamsFromOffset(offset)));\n  }\n  _scrollToParamsFromOffset(offset) {\n    const {\n      horizontal,\n      rtl\n    } = this._orientation();\n    if (horizontal && rtl) {\n      const cartOffset = this._listMetrics.cartesianOffset(offset + this._scrollMetrics.visibleLength);\n      return horizontal ? {\n        x: cartOffset\n      } : {\n        y: cartOffset\n      };\n    } else {\n      return horizontal ? {\n        x: offset\n      } : {\n        y: offset\n      };\n    }\n  }\n  recordInteraction() {\n    this._nestedChildLists.forEach(childList => {\n      childList.recordInteraction();\n    });\n    this._viewabilityTuples.forEach(t => {\n      t.viewabilityHelper.recordInteraction();\n    });\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  }\n  flashScrollIndicators() {\n    if (this._scrollRef == null) {\n      return;\n    }\n    this._scrollRef.flashScrollIndicators();\n  }\n  getScrollResponder() {\n    if (this._scrollRef && this._scrollRef.getScrollResponder) {\n      return this._scrollRef.getScrollResponder();\n    }\n  }\n  getScrollableNode() {\n    if (this._scrollRef && this._scrollRef.getScrollableNode) {\n      return this._scrollRef.getScrollableNode();\n    } else {\n      return findNodeHandle(this._scrollRef);\n    }\n  }\n  getScrollRef() {\n    if (this._scrollRef && this._scrollRef.getScrollRef) {\n      return this._scrollRef.getScrollRef();\n    } else {\n      return this._scrollRef;\n    }\n  }\n  setNativeProps(props) {\n    if (this._scrollRef) {\n      this._scrollRef.setNativeProps(props);\n    }\n  }\n  _getCellKey() {\n    return this.context?.cellKey || 'rootList';\n  }\n  hasMore() {\n    return this._hasMore;\n  }\n  constructor(_props) {\n    super(_props);\n    this._getScrollMetrics = () => {\n      return this._scrollMetrics;\n    };\n    this._getOutermostParentListRef = () => {\n      if (this._isNestedWithSameOrientation()) {\n        return this.context.getOutermostParentListRef();\n      } else {\n        return this;\n      }\n    };\n    this._registerAsNestedChild = childList => {\n      this._nestedChildLists.add(childList.ref, childList.cellKey);\n      if (this._hasInteracted) {\n        childList.ref.recordInteraction();\n      }\n    };\n    this._unregisterAsNestedChild = childList => {\n      this._nestedChildLists.remove(childList.ref);\n    };\n    this.state = void 0;\n    this._onUpdateSeparators = (keys, newProps) => {\n      keys.forEach(key => {\n        const ref = key != null && this._cellRefs[key];\n        ref && ref.updateSeparatorProps(newProps);\n      });\n    };\n    this._getSpacerKey = isVertical => isVertical ? 'height' : 'width';\n    this._cellRefs = {};\n    this._fillRateHelper = void 0;\n    this._listMetrics = new ListMetricsAggregator();\n    this._footerLength = 0;\n    this._hasTriggeredInitialScrollToIndex = false;\n    this._hasInteracted = false;\n    this._hasMore = false;\n    this._hasWarned = {};\n    this._headerLength = 0;\n    this._hiPriInProgress = false;\n    this._indicesToKeys = new Map();\n    this._lastFocusedCellKey = null;\n    this._nestedChildLists = new ChildListCollection();\n    this._offsetFromParentVirtualizedList = 0;\n    this._pendingViewabilityUpdate = false;\n    this._prevParentOffset = 0;\n    this._scrollMetrics = {\n      dOffset: 0,\n      dt: 10,\n      offset: 0,\n      timestamp: 0,\n      velocity: 0,\n      visibleLength: 0,\n      zoomScale: 1\n    };\n    this._scrollRef = null;\n    this._sentStartForContentLength = 0;\n    this._sentEndForContentLength = 0;\n    this._updateCellsToRenderBatcher = void 0;\n    this._viewabilityTuples = [];\n    this._captureScrollRef = ref => {\n      this._scrollRef = ref;\n    };\n    this._defaultRenderScrollComponent = props => {\n      const onRefresh = props.onRefresh;\n      if (this._isNestedWithSameOrientation()) {\n        const otherProps = _objectWithoutPropertiesLoose(props, _excluded);\n        return _jsxDEV(View, Object.assign({}, otherProps), void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1249,\n          columnNumber: 14\n        }, this);\n      } else if (onRefresh) {\n        invariant(typeof props.refreshing === 'boolean', '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' + JSON.stringify(props.refreshing ?? 'undefined') + '`');\n        return _jsxDEV(ScrollView, Object.assign({}, props, {\n          refreshControl: props.refreshControl == null ? _jsxDEV(RefreshControl, {\n            refreshing: props.refreshing,\n            onRefresh: onRefresh,\n            progressViewOffset: props.progressViewOffset\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1264,\n            columnNumber: 15\n          }, this) : props.refreshControl\n        }), void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1260,\n          columnNumber: 9\n        }, this);\n      } else {\n        return _jsxDEV(ScrollView, Object.assign({}, props), void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1279,\n          columnNumber: 14\n        }, this);\n      }\n    };\n    this._onCellLayout = (e, cellKey, cellIndex) => {\n      const layoutHasChanged = this._listMetrics.notifyCellLayout({\n        cellIndex,\n        cellKey,\n        layout: e.nativeEvent.layout,\n        orientation: this._orientation()\n      });\n      if (layoutHasChanged) {\n        this._scheduleCellsToRenderUpdate();\n      }\n      this._triggerRemeasureForChildListsInCell(cellKey);\n      this._computeBlankness();\n      this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n    };\n    this._onCellFocusCapture = cellKey => {\n      this._lastFocusedCellKey = cellKey;\n      this._updateCellsToRender();\n    };\n    this._onCellUnmount = cellKey => {\n      delete this._cellRefs[cellKey];\n      this._listMetrics.notifyCellUnmounted(cellKey);\n    };\n    this._onLayout = e => {\n      if (this._isNestedWithSameOrientation()) {\n        this.measureLayoutRelativeToContainingList();\n      } else {\n        this._scrollMetrics.visibleLength = this._selectLength(e.nativeEvent.layout);\n      }\n      this.props.onLayout && this.props.onLayout(e);\n      this._scheduleCellsToRenderUpdate();\n      this._maybeCallOnEdgeReached();\n    };\n    this._onLayoutEmpty = e => {\n      this.props.onLayout && this.props.onLayout(e);\n    };\n    this._onLayoutFooter = e => {\n      this._triggerRemeasureForChildListsInCell(this._getFooterCellKey());\n      this._footerLength = this._selectLength(e.nativeEvent.layout);\n    };\n    this._onLayoutHeader = e => {\n      this._headerLength = this._selectLength(e.nativeEvent.layout);\n    };\n    this._onContentSizeChange = (width, height) => {\n      this._listMetrics.notifyListContentLayout({\n        layout: {\n          width,\n          height\n        },\n        orientation: this._orientation()\n      });\n      this._maybeScrollToInitialScrollIndex(width, height);\n      if (this.props.onContentSizeChange) {\n        this.props.onContentSizeChange(width, height);\n      }\n      this._scheduleCellsToRenderUpdate();\n      this._maybeCallOnEdgeReached();\n    };\n    this._convertParentScrollMetrics = metrics => {\n      const offset = metrics.offset - this._offsetFromParentVirtualizedList;\n      const visibleLength = metrics.visibleLength;\n      const dOffset = offset - this._scrollMetrics.offset;\n      const contentLength = this._listMetrics.getContentLength();\n      return {\n        visibleLength,\n        contentLength,\n        offset,\n        dOffset\n      };\n    };\n    this._onScroll = e => {\n      this._nestedChildLists.forEach(childList => {\n        childList._onScroll(e);\n      });\n      if (this.props.onScroll) {\n        this.props.onScroll(e);\n      }\n      const timestamp = e.timeStamp;\n      let visibleLength = this._selectLength(e.nativeEvent.layoutMeasurement);\n      let contentLength = this._selectLength(e.nativeEvent.contentSize);\n      let offset = this._offsetFromScrollEvent(e);\n      let dOffset = offset - this._scrollMetrics.offset;\n      if (this._isNestedWithSameOrientation()) {\n        if (this._listMetrics.getContentLength() === 0) {\n          return;\n        }\n        ({\n          visibleLength,\n          contentLength,\n          offset,\n          dOffset\n        } = this._convertParentScrollMetrics({\n          visibleLength,\n          offset\n        }));\n      }\n      const dt = this._scrollMetrics.timestamp ? Math.max(1, timestamp - this._scrollMetrics.timestamp) : 1;\n      const velocity = dOffset / dt;\n      if (dt > 500 && this._scrollMetrics.dt > 500 && contentLength > 5 * visibleLength && !this._hasWarned.perf) {\n        infoLog('VirtualizedList: You have a large list that is slow to update - make sure your ' + 'renderItem function renders components that follow React performance best practices ' + 'like PureComponent, shouldComponentUpdate, etc.', {\n          dt,\n          prevDt: this._scrollMetrics.dt,\n          contentLength\n        });\n        this._hasWarned.perf = true;\n      }\n      const zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;\n      this._scrollMetrics = {\n        dt,\n        dOffset,\n        offset,\n        timestamp,\n        velocity,\n        visibleLength,\n        zoomScale\n      };\n      if (this.state.pendingScrollUpdateCount > 0) {\n        this.setState(state => ({\n          pendingScrollUpdateCount: state.pendingScrollUpdateCount - 1\n        }));\n      }\n      this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n      if (!this.props) {\n        return;\n      }\n      this._maybeCallOnEdgeReached();\n      if (velocity !== 0) {\n        this._fillRateHelper.activate();\n      }\n      this._computeBlankness();\n      this._scheduleCellsToRenderUpdate();\n    };\n    this._onScrollBeginDrag = e => {\n      this._nestedChildLists.forEach(childList => {\n        childList._onScrollBeginDrag(e);\n      });\n      this._viewabilityTuples.forEach(tuple => {\n        tuple.viewabilityHelper.recordInteraction();\n      });\n      this._hasInteracted = true;\n      this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n    };\n    this._onScrollEndDrag = e => {\n      this._nestedChildLists.forEach(childList => {\n        childList._onScrollEndDrag(e);\n      });\n      const {\n        velocity\n      } = e.nativeEvent;\n      if (velocity) {\n        this._scrollMetrics.velocity = this._selectOffset(velocity);\n      }\n      this._computeBlankness();\n      this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n    };\n    this._onMomentumScrollBegin = e => {\n      this._nestedChildLists.forEach(childList => {\n        childList._onMomentumScrollBegin(e);\n      });\n      this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n    };\n    this._onMomentumScrollEnd = e => {\n      this._nestedChildLists.forEach(childList => {\n        childList._onMomentumScrollEnd(e);\n      });\n      this._scrollMetrics.velocity = 0;\n      this._computeBlankness();\n      this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n    };\n    this._updateCellsToRender = () => {\n      this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n      this.setState((state, props) => {\n        const cellsAroundViewport = this._adjustCellsAroundViewport(props, state.cellsAroundViewport, state.pendingScrollUpdateCount);\n        const renderMask = VirtualizedList._createRenderMask(props, cellsAroundViewport, this._getNonViewportRenderRegions(props));\n        if (cellsAroundViewport.first === state.cellsAroundViewport.first && cellsAroundViewport.last === state.cellsAroundViewport.last && renderMask.equals(state.renderMask)) {\n          return null;\n        }\n        return {\n          cellsAroundViewport,\n          renderMask\n        };\n      });\n    };\n    this._createViewToken = (index, isViewable, props) => {\n      const {\n        data,\n        getItem\n      } = props;\n      const item = getItem(data, index);\n      return {\n        index,\n        item,\n        key: VirtualizedList._keyExtractor(item, index, props),\n        isViewable\n      };\n    };\n    this._getNonViewportRenderRegions = props => {\n      if (!(this._lastFocusedCellKey && this._cellRefs[this._lastFocusedCellKey])) {\n        return [];\n      }\n      const lastFocusedCellRenderer = this._cellRefs[this._lastFocusedCellKey];\n      const focusedCellIndex = lastFocusedCellRenderer.props.index;\n      const itemCount = props.getItemCount(props.data);\n      if (focusedCellIndex >= itemCount || VirtualizedList._getItemKey(props, focusedCellIndex) !== this._lastFocusedCellKey) {\n        return [];\n      }\n      let first = focusedCellIndex;\n      let heightOfCellsBeforeFocused = 0;\n      for (let i = first - 1; i >= 0 && heightOfCellsBeforeFocused < this._scrollMetrics.visibleLength; i--) {\n        first--;\n        heightOfCellsBeforeFocused += this._listMetrics.getCellMetricsApprox(i, props).length;\n      }\n      let last = focusedCellIndex;\n      let heightOfCellsAfterFocused = 0;\n      for (let i = last + 1; i < itemCount && heightOfCellsAfterFocused < this._scrollMetrics.visibleLength; i++) {\n        last++;\n        heightOfCellsAfterFocused += this._listMetrics.getCellMetricsApprox(i, props).length;\n      }\n      return [{\n        first,\n        last\n      }];\n    };\n    this._checkProps(_props);\n    this._fillRateHelper = new FillRateHelper(this._listMetrics);\n    this._updateCellsToRenderBatcher = new Batchinator(this._updateCellsToRender, this.props.updateCellsBatchingPeriod ?? 50);\n    if (this.props.viewabilityConfigCallbackPairs) {\n      this._viewabilityTuples = this.props.viewabilityConfigCallbackPairs.map(pair => ({\n        viewabilityHelper: new ViewabilityHelper(pair.viewabilityConfig),\n        onViewableItemsChanged: pair.onViewableItemsChanged\n      }));\n    } else {\n      const {\n        onViewableItemsChanged,\n        viewabilityConfig\n      } = this.props;\n      if (onViewableItemsChanged) {\n        this._viewabilityTuples.push({\n          viewabilityHelper: new ViewabilityHelper(viewabilityConfig),\n          onViewableItemsChanged: onViewableItemsChanged\n        });\n      }\n    }\n    const initialRenderRegion = VirtualizedList._initialRenderRegion(_props);\n    const minIndexForVisible = this.props.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n    this.state = {\n      cellsAroundViewport: initialRenderRegion,\n      renderMask: VirtualizedList._createRenderMask(_props, initialRenderRegion),\n      firstVisibleItemKey: this.props.getItemCount(this.props.data) > minIndexForVisible ? VirtualizedList._getItemKey(this.props, minIndexForVisible) : null,\n      pendingScrollUpdateCount: this.props.initialScrollIndex != null && this.props.initialScrollIndex > 0 ? 1 : 0\n    };\n  }\n  _checkProps(props) {\n    const {\n      onScroll,\n      windowSize,\n      getItemCount,\n      data,\n      initialScrollIndex\n    } = props;\n    invariant(!onScroll || !onScroll.__isNative, 'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' + 'to support native onScroll events with useNativeDriver');\n    invariant(windowSizeOrDefault(windowSize) > 0, 'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.');\n    invariant(getItemCount, 'VirtualizedList: The \"getItemCount\" prop must be provided');\n    const itemCount = getItemCount(data);\n    if (initialScrollIndex != null && !this._hasTriggeredInitialScrollToIndex && (initialScrollIndex < 0 || itemCount > 0 && initialScrollIndex >= itemCount) && !this._hasWarned.initialScrollIndex) {\n      console.warn(`initialScrollIndex \"${initialScrollIndex}\" is not valid (list has ${itemCount} items)`);\n      this._hasWarned.initialScrollIndex = true;\n    }\n    if (__DEV__ && !this._hasWarned.flexWrap) {\n      const flatStyles = StyleSheet.flatten(this.props.contentContainerStyle);\n      if (flatStyles != null && flatStyles.flexWrap === 'wrap') {\n        console.warn('`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' + 'Consider using `numColumns` with `FlatList` instead.');\n        this._hasWarned.flexWrap = true;\n      }\n    }\n  }\n  static _findItemIndexWithKey(props, key, hint) {\n    const itemCount = props.getItemCount(props.data);\n    if (hint != null && hint >= 0 && hint < itemCount) {\n      const curKey = VirtualizedList._getItemKey(props, hint);\n      if (curKey === key) {\n        return hint;\n      }\n    }\n    for (let ii = 0; ii < itemCount; ii++) {\n      const curKey = VirtualizedList._getItemKey(props, ii);\n      if (curKey === key) {\n        return ii;\n      }\n    }\n    return null;\n  }\n  static _getItemKey(props, index) {\n    const item = props.getItem(props.data, index);\n    return VirtualizedList._keyExtractor(item, index, props);\n  }\n  static _createRenderMask(props, cellsAroundViewport, additionalRegions) {\n    const itemCount = props.getItemCount(props.data);\n    invariant(cellsAroundViewport.first >= 0 && cellsAroundViewport.last >= cellsAroundViewport.first - 1 && cellsAroundViewport.last < itemCount, `Invalid cells around viewport \"[${cellsAroundViewport.first}, ${cellsAroundViewport.last}]\" was passed to VirtualizedList._createRenderMask`);\n    const renderMask = new CellRenderMask(itemCount);\n    if (itemCount > 0) {\n      const allRegions = [cellsAroundViewport, ...(additionalRegions ?? [])];\n      for (const region of allRegions) {\n        renderMask.addCells(region);\n      }\n      if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {\n        const initialRegion = VirtualizedList._initialRenderRegion(props);\n        renderMask.addCells(initialRegion);\n      }\n      const stickyIndicesSet = new Set(props.stickyHeaderIndices);\n      VirtualizedList._ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellsAroundViewport.first);\n    }\n    return renderMask;\n  }\n  static _initialRenderRegion(props) {\n    const itemCount = props.getItemCount(props.data);\n    const firstCellIndex = Math.max(0, Math.min(itemCount - 1, Math.floor(props.initialScrollIndex ?? 0)));\n    const lastCellIndex = Math.min(itemCount, firstCellIndex + initialNumToRenderOrDefault(props.initialNumToRender)) - 1;\n    return {\n      first: firstCellIndex,\n      last: lastCellIndex\n    };\n  }\n  static _ensureClosestStickyHeader(props, stickyIndicesSet, renderMask, cellIdx) {\n    const stickyOffset = props.ListHeaderComponent ? 1 : 0;\n    for (let itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--) {\n      if (stickyIndicesSet.has(itemIdx + stickyOffset)) {\n        renderMask.addCells({\n          first: itemIdx,\n          last: itemIdx\n        });\n        break;\n      }\n    }\n  }\n  _adjustCellsAroundViewport(props, cellsAroundViewport, pendingScrollUpdateCount) {\n    const {\n      data,\n      getItemCount\n    } = props;\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(props.onEndReachedThreshold);\n    const {\n      offset,\n      visibleLength\n    } = this._scrollMetrics;\n    const contentLength = this._listMetrics.getContentLength();\n    const distanceFromEnd = contentLength - visibleLength - offset;\n    if (visibleLength <= 0 || contentLength <= 0) {\n      return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;\n    }\n    let newCellsAroundViewport;\n    if (props.disableVirtualization) {\n      const renderAhead = distanceFromEnd < onEndReachedThreshold * visibleLength ? maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch) : 0;\n      newCellsAroundViewport = {\n        first: 0,\n        last: Math.min(cellsAroundViewport.last + renderAhead, getItemCount(data) - 1)\n      };\n    } else {\n      if (pendingScrollUpdateCount > 0) {\n        return cellsAroundViewport.last >= getItemCount(data) ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props) : cellsAroundViewport;\n      }\n      newCellsAroundViewport = computeWindowedRenderLimits(props, maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch), windowSizeOrDefault(props.windowSize), cellsAroundViewport, this._listMetrics, this._scrollMetrics);\n      invariant(newCellsAroundViewport.last < getItemCount(data), 'computeWindowedRenderLimits() should return range in-bounds');\n    }\n    if (this._nestedChildLists.size() > 0) {\n      const childIdx = this._findFirstChildWithMore(newCellsAroundViewport.first, newCellsAroundViewport.last);\n      newCellsAroundViewport.last = childIdx ?? newCellsAroundViewport.last;\n    }\n    return newCellsAroundViewport;\n  }\n  _findFirstChildWithMore(first, last) {\n    for (let ii = first; ii <= last; ii++) {\n      const cellKeyForIndex = this._indicesToKeys.get(ii);\n      if (cellKeyForIndex != null && this._nestedChildLists.anyInCell(cellKeyForIndex, childList => childList.hasMore())) {\n        return ii;\n      }\n    }\n    return null;\n  }\n  componentDidMount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.registerAsNestedChild({\n        ref: this,\n        cellKey: this.context.cellKey\n      });\n    }\n  }\n  componentWillUnmount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.unregisterAsNestedChild({\n        ref: this\n      });\n    }\n    this._updateCellsToRenderBatcher.dispose({\n      abort: true\n    });\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.dispose();\n    });\n    this._fillRateHelper.deactivateAndFlush();\n  }\n  static getDerivedStateFromProps(newProps, prevState) {\n    const itemCount = newProps.getItemCount(newProps.data);\n    if (itemCount === prevState.renderMask.numCells()) {\n      return prevState;\n    }\n    let maintainVisibleContentPositionAdjustment = null;\n    const prevFirstVisibleItemKey = prevState.firstVisibleItemKey;\n    const minIndexForVisible = newProps.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n    const newFirstVisibleItemKey = newProps.getItemCount(newProps.data) > minIndexForVisible ? VirtualizedList._getItemKey(newProps, minIndexForVisible) : null;\n    if (newProps.maintainVisibleContentPosition != null && prevFirstVisibleItemKey != null && newFirstVisibleItemKey != null) {\n      if (newFirstVisibleItemKey !== prevFirstVisibleItemKey) {\n        const hint = itemCount - prevState.renderMask.numCells() + minIndexForVisible;\n        const firstVisibleItemIndex = VirtualizedList._findItemIndexWithKey(newProps, prevFirstVisibleItemKey, hint);\n        maintainVisibleContentPositionAdjustment = firstVisibleItemIndex != null ? firstVisibleItemIndex - minIndexForVisible : null;\n      } else {\n        maintainVisibleContentPositionAdjustment = null;\n      }\n    }\n    const constrainedCells = VirtualizedList._constrainToItemCount(maintainVisibleContentPositionAdjustment != null ? {\n      first: prevState.cellsAroundViewport.first + maintainVisibleContentPositionAdjustment,\n      last: prevState.cellsAroundViewport.last + maintainVisibleContentPositionAdjustment\n    } : prevState.cellsAroundViewport, newProps);\n    return {\n      cellsAroundViewport: constrainedCells,\n      renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),\n      firstVisibleItemKey: newFirstVisibleItemKey,\n      pendingScrollUpdateCount: maintainVisibleContentPositionAdjustment != null ? prevState.pendingScrollUpdateCount + 1 : prevState.pendingScrollUpdateCount\n    };\n  }\n  _pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, first, last, inversionStyle) {\n    const {\n      CellRendererComponent,\n      ItemSeparatorComponent,\n      ListHeaderComponent,\n      ListItemComponent,\n      data,\n      debug,\n      getItem,\n      getItemCount,\n      getItemLayout,\n      horizontal,\n      renderItem\n    } = this.props;\n    const stickyOffset = ListHeaderComponent ? 1 : 0;\n    const end = getItemCount(data) - 1;\n    let prevCellKey;\n    last = Math.min(end, last);\n    for (let ii = first; ii <= last; ii++) {\n      const item = getItem(data, ii);\n      const key = VirtualizedList._keyExtractor(item, ii, this.props);\n      this._indicesToKeys.set(ii, key);\n      if (stickyIndicesFromProps.has(ii + stickyOffset)) {\n        stickyHeaderIndices.push(cells.length);\n      }\n      const shouldListenForLayout = getItemLayout == null || debug || this._fillRateHelper.enabled();\n      cells.push(_jsxDEV(CellRenderer, Object.assign({\n        CellRendererComponent: CellRendererComponent,\n        ItemSeparatorComponent: ii < end ? ItemSeparatorComponent : undefined,\n        ListItemComponent: ListItemComponent,\n        cellKey: key,\n        horizontal: horizontal,\n        index: ii,\n        inversionStyle: inversionStyle,\n        item: item,\n        prevCellKey: prevCellKey,\n        onUpdateSeparators: this._onUpdateSeparators,\n        onCellFocusCapture: this._onCellFocusCapture,\n        onUnmount: this._onCellUnmount,\n        ref: ref => {\n          this._cellRefs[key] = ref;\n        },\n        renderItem: renderItem\n      }, shouldListenForLayout && {\n        onCellLayout: this._onCellLayout\n      }), key, false, {\n        fileName: _jsxFileName,\n        lineNumber: 802,\n        columnNumber: 9\n      }, this));\n      prevCellKey = key;\n    }\n  }\n  static _constrainToItemCount(cells, props) {\n    const itemCount = props.getItemCount(props.data);\n    const lastPossibleCellIndex = itemCount - 1;\n    const maxToRenderPerBatch = maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch);\n    const maxFirst = Math.max(0, lastPossibleCellIndex - maxToRenderPerBatch);\n    return {\n      first: clamp(0, cells.first, maxFirst),\n      last: Math.min(lastPossibleCellIndex, cells.last)\n    };\n  }\n  _isNestedWithSameOrientation() {\n    const nestedContext = this.context;\n    return !!(nestedContext && !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal));\n  }\n  static _keyExtractor(item, index, props) {\n    if (props.keyExtractor != null) {\n      return props.keyExtractor(item, index);\n    }\n    const key = defaultKeyExtractor(item, index);\n    if (key === String(index)) {\n      _usedIndexForKey = true;\n      if (item.type && item.type.displayName) {\n        _keylessItemComponentName = item.type.displayName;\n      }\n    }\n    return key;\n  }\n  render() {\n    this._checkProps(this.props);\n    const {\n      ListEmptyComponent,\n      ListFooterComponent,\n      ListHeaderComponent\n    } = this.props;\n    const {\n      data,\n      horizontal\n    } = this.props;\n    const inversionStyle = this.props.inverted ? horizontalOrDefault(this.props.horizontal) ? styles.horizontallyInverted : styles.verticallyInverted : null;\n    const cells = [];\n    const stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);\n    const stickyHeaderIndices = [];\n    if (ListHeaderComponent) {\n      if (stickyIndicesFromProps.has(0)) {\n        stickyHeaderIndices.push(0);\n      }\n      const element = React.isValidElement(ListHeaderComponent) ? ListHeaderComponent : _jsxDEV(ListHeaderComponent, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 914,\n        columnNumber: 9\n      }, this);\n      cells.push(_jsxDEV(VirtualizedListCellContextProvider, {\n        cellKey: this._getCellKey() + '-header',\n        children: _jsxDEV(View, {\n          collapsable: false,\n          onLayout: this._onLayoutHeader,\n          style: StyleSheet.compose(inversionStyle, this.props.ListHeaderComponentStyle),\n          children: element\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 920,\n          columnNumber: 11\n        }, this)\n      }, \"$header\", false, {\n        fileName: _jsxFileName,\n        lineNumber: 917,\n        columnNumber: 9\n      }, this));\n    }\n    const itemCount = this.props.getItemCount(data);\n    if (itemCount === 0 && ListEmptyComponent) {\n      const element = React.isValidElement(ListEmptyComponent) ? ListEmptyComponent : _jsxDEV(ListEmptyComponent, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 949,\n        columnNumber: 9\n      }, this);\n      cells.push(_jsxDEV(VirtualizedListCellContextProvider, {\n        cellKey: this._getCellKey() + '-empty',\n        children: React.cloneElement(element, {\n          onLayout: event => {\n            this._onLayoutEmpty(event);\n            if (element.props.onLayout) {\n              element.props.onLayout(event);\n            }\n          },\n          style: StyleSheet.compose(inversionStyle, element.props.style)\n        })\n      }, \"$empty\", false, {\n        fileName: _jsxFileName,\n        lineNumber: 952,\n        columnNumber: 9\n      }, this));\n    }\n    if (itemCount > 0) {\n      _usedIndexForKey = false;\n      _keylessItemComponentName = '';\n      const spacerKey = this._getSpacerKey(!horizontal);\n      const renderRegions = this.state.renderMask.enumerateRegions();\n      const lastRegion = renderRegions[renderRegions.length - 1];\n      const lastSpacer = lastRegion?.isSpacer ? lastRegion : null;\n      for (const section of renderRegions) {\n        if (section.isSpacer) {\n          if (this.props.disableVirtualization) {\n            continue;\n          }\n          const isLastSpacer = section === lastSpacer;\n          const constrainToMeasured = isLastSpacer && !this.props.getItemLayout;\n          const last = constrainToMeasured ? clamp(section.first - 1, section.last, this._listMetrics.getHighestMeasuredCellIndex()) : section.last;\n          const firstMetrics = this._listMetrics.getCellMetricsApprox(section.first, this.props);\n          const lastMetrics = this._listMetrics.getCellMetricsApprox(last, this.props);\n          const spacerSize = lastMetrics.offset + lastMetrics.length - firstMetrics.offset;\n          cells.push(_jsxDEV(View, {\n            style: {\n              [spacerKey]: spacerSize\n            }\n          }, `$spacer-${section.first}`, false, {\n            fileName: _jsxFileName,\n            lineNumber: 1012,\n            columnNumber: 13\n          }, this));\n        } else {\n          this._pushCells(cells, stickyHeaderIndices, stickyIndicesFromProps, section.first, section.last, inversionStyle);\n        }\n      }\n      if (!this._hasWarned.keys && _usedIndexForKey) {\n        console.warn('VirtualizedList: missing keys for items, make sure to specify a key or id property on each ' + 'item or provide a custom keyExtractor.', _keylessItemComponentName);\n        this._hasWarned.keys = true;\n      }\n    }\n    if (ListFooterComponent) {\n      const element = React.isValidElement(ListFooterComponent) ? ListFooterComponent : _jsxDEV(ListFooterComponent, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1046,\n        columnNumber: 9\n      }, this);\n      cells.push(_jsxDEV(VirtualizedListCellContextProvider, {\n        cellKey: this._getFooterCellKey(),\n        children: _jsxDEV(View, {\n          onLayout: this._onLayoutFooter,\n          style: StyleSheet.compose(inversionStyle, this.props.ListFooterComponentStyle),\n          children: element\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 1052,\n          columnNumber: 11\n        }, this)\n      }, \"$footer\", false, {\n        fileName: _jsxFileName,\n        lineNumber: 1049,\n        columnNumber: 9\n      }, this));\n    }\n    const scrollProps = Object.assign({}, this.props, {\n      onContentSizeChange: this._onContentSizeChange,\n      onLayout: this._onLayout,\n      onScroll: this._onScroll,\n      onScrollBeginDrag: this._onScrollBeginDrag,\n      onScrollEndDrag: this._onScrollEndDrag,\n      onMomentumScrollBegin: this._onMomentumScrollBegin,\n      onMomentumScrollEnd: this._onMomentumScrollEnd,\n      scrollEventThrottle: this.props.scrollEventThrottle ?? 0.0001,\n      invertStickyHeaders: this.props.invertStickyHeaders !== undefined ? this.props.invertStickyHeaders : this.props.inverted,\n      stickyHeaderIndices,\n      style: inversionStyle ? [inversionStyle, this.props.style] : this.props.style,\n      isInvertedVirtualizedList: this.props.inverted,\n      maintainVisibleContentPosition: this.props.maintainVisibleContentPosition != null ? Object.assign({}, this.props.maintainVisibleContentPosition, {\n        minIndexForVisible: this.props.maintainVisibleContentPosition.minIndexForVisible + (this.props.ListHeaderComponent ? 1 : 0)\n      }) : undefined\n    });\n    this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;\n    const innerRet = _jsxDEV(VirtualizedListContextProvider, {\n      value: {\n        cellKey: null,\n        getScrollMetrics: this._getScrollMetrics,\n        horizontal: horizontalOrDefault(this.props.horizontal),\n        getOutermostParentListRef: this._getOutermostParentListRef,\n        registerAsNestedChild: this._registerAsNestedChild,\n        unregisterAsNestedChild: this._unregisterAsNestedChild\n      },\n      children: React.cloneElement((this.props.renderScrollComponent || this._defaultRenderScrollComponent)(scrollProps), {\n        ref: this._captureScrollRef\n      }, cells)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 1104,\n      columnNumber: 7\n    }, this);\n    let ret = innerRet;\n    if (__DEV__) {\n      ret = _jsxDEV(ScrollView.Context.Consumer, {\n        children: scrollContext => {\n          if (scrollContext != null && !scrollContext.horizontal === !horizontalOrDefault(this.props.horizontal) && !this._hasWarned.nesting && this.context == null && this.props.scrollEnabled !== false) {\n            console.error('VirtualizedLists should never be nested inside plain ScrollViews with the same ' + 'orientation because it can break windowing and other functionality - use another ' + 'VirtualizedList-backed container instead.');\n            this._hasWarned.nesting = true;\n          }\n          return innerRet;\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1128,\n        columnNumber: 9\n      }, this);\n    }\n    if (this.props.debug) {\n      return _jsxDEV(View, {\n        style: styles.debug,\n        children: [ret, this._renderDebugOverlay()]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 1152,\n        columnNumber: 9\n      }, this);\n    } else {\n      return ret;\n    }\n  }\n  componentDidUpdate(prevProps) {\n    const {\n      data,\n      extraData\n    } = this.props;\n    if (data !== prevProps.data || extraData !== prevProps.extraData) {\n      this._viewabilityTuples.forEach(tuple => {\n        tuple.viewabilityHelper.resetViewableIndices();\n      });\n    }\n    const hiPriInProgress = this._hiPriInProgress;\n    this._scheduleCellsToRenderUpdate();\n    if (hiPriInProgress) {\n      this._hiPriInProgress = false;\n    }\n  }\n  _computeBlankness() {\n    this._fillRateHelper.computeBlankness(this.props, this.state.cellsAroundViewport, this._scrollMetrics);\n  }\n  _triggerRemeasureForChildListsInCell(cellKey) {\n    this._nestedChildLists.forEachInCell(cellKey, childList => {\n      childList.measureLayoutRelativeToContainingList();\n    });\n  }\n  measureLayoutRelativeToContainingList() {\n    try {\n      if (!this._scrollRef) {\n        return;\n      }\n      this._scrollRef.measureLayout(this.context.getOutermostParentListRef().getScrollRef(), (x, y, width, height) => {\n        this._offsetFromParentVirtualizedList = this._selectOffset({\n          x,\n          y\n        });\n        this._listMetrics.notifyListContentLayout({\n          layout: {\n            width,\n            height\n          },\n          orientation: this._orientation()\n        });\n        const scrollMetrics = this._convertParentScrollMetrics(this.context.getScrollMetrics());\n        const metricsChanged = this._scrollMetrics.visibleLength !== scrollMetrics.visibleLength || this._scrollMetrics.offset !== scrollMetrics.offset;\n        if (metricsChanged) {\n          this._scrollMetrics.visibleLength = scrollMetrics.visibleLength;\n          this._scrollMetrics.offset = scrollMetrics.offset;\n          this._nestedChildLists.forEach(childList => {\n            childList.measureLayoutRelativeToContainingList();\n          });\n        }\n      }, error => {\n        console.warn(\"VirtualizedList: Encountered an error while measuring a list's\" + ' offset from its containing VirtualizedList.');\n      });\n    } catch (error) {\n      console.warn('measureLayoutRelativeToContainingList threw an error', error.stack);\n    }\n  }\n  _getFooterCellKey() {\n    return this._getCellKey() + '-footer';\n  }\n  _renderDebugOverlay() {\n    const normalize = this._scrollMetrics.visibleLength / (this._listMetrics.getContentLength() || 1);\n    const framesInLayout = [];\n    const itemCount = this.props.getItemCount(this.props.data);\n    for (let ii = 0; ii < itemCount; ii++) {\n      const frame = this._listMetrics.getCellMetricsApprox(ii, this.props);\n      if (frame.isMounted) {\n        framesInLayout.push(frame);\n      }\n    }\n    const windowTop = this._listMetrics.getCellMetricsApprox(this.state.cellsAroundViewport.first, this.props).offset;\n    const frameLast = this._listMetrics.getCellMetricsApprox(this.state.cellsAroundViewport.last, this.props);\n    const windowLen = frameLast.offset + frameLast.length - windowTop;\n    const visTop = this._scrollMetrics.offset;\n    const visLen = this._scrollMetrics.visibleLength;\n    return _jsxDEV(View, {\n      style: [styles.debugOverlayBase, styles.debugOverlay],\n      children: [framesInLayout.map((f, ii) => _jsxDEV(View, {\n        style: [styles.debugOverlayBase, styles.debugOverlayFrame, {\n          top: f.offset * normalize,\n          height: f.length * normalize\n        }]\n      }, 'f' + ii, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1431,\n        columnNumber: 11\n      }, this)), _jsxDEV(View, {\n        style: [styles.debugOverlayBase, styles.debugOverlayFrameLast, {\n          top: windowTop * normalize,\n          height: windowLen * normalize\n        }]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1443,\n        columnNumber: 9\n      }, this), _jsxDEV(View, {\n        style: [styles.debugOverlayBase, styles.debugOverlayFrameVis, {\n          top: visTop * normalize,\n          height: visLen * normalize\n        }]\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 1453,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 1429,\n      columnNumber: 7\n    }, this);\n  }\n  _selectLength(metrics) {\n    return !horizontalOrDefault(this.props.horizontal) ? metrics.height : metrics.width;\n  }\n  _selectOffset({\n    x,\n    y\n  }) {\n    return this._orientation().horizontal ? x : y;\n  }\n  _orientation() {\n    return {\n      horizontal: horizontalOrDefault(this.props.horizontal),\n      rtl: I18nManager.isRTL\n    };\n  }\n  _maybeCallOnEdgeReached() {\n    const {\n      data,\n      getItemCount,\n      onStartReached,\n      onStartReachedThreshold,\n      onEndReached,\n      onEndReachedThreshold\n    } = this.props;\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n    const {\n      visibleLength,\n      offset\n    } = this._scrollMetrics;\n    let distanceFromStart = offset;\n    let distanceFromEnd = this._listMetrics.getContentLength() - visibleLength - offset;\n    if (distanceFromStart < ON_EDGE_REACHED_EPSILON) {\n      distanceFromStart = 0;\n    }\n    if (distanceFromEnd < ON_EDGE_REACHED_EPSILON) {\n      distanceFromEnd = 0;\n    }\n    const DEFAULT_THRESHOLD_PX = 2;\n    const startThreshold = onStartReachedThreshold != null ? onStartReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;\n    const endThreshold = onEndReachedThreshold != null ? onEndReachedThreshold * visibleLength : DEFAULT_THRESHOLD_PX;\n    const isWithinStartThreshold = distanceFromStart <= startThreshold;\n    const isWithinEndThreshold = distanceFromEnd <= endThreshold;\n    if (onEndReached && this.state.cellsAroundViewport.last === getItemCount(data) - 1 && isWithinEndThreshold && this._listMetrics.getContentLength() !== this._sentEndForContentLength) {\n      this._sentEndForContentLength = this._listMetrics.getContentLength();\n      onEndReached({\n        distanceFromEnd\n      });\n    }\n    if (onStartReached != null && this.state.cellsAroundViewport.first === 0 && isWithinStartThreshold && this._listMetrics.getContentLength() !== this._sentStartForContentLength) {\n      this._sentStartForContentLength = this._listMetrics.getContentLength();\n      onStartReached({\n        distanceFromStart\n      });\n    }\n    if (!isWithinStartThreshold) {\n      this._sentStartForContentLength = 0;\n    }\n    if (!isWithinEndThreshold) {\n      this._sentEndForContentLength = 0;\n    }\n  }\n  _maybeScrollToInitialScrollIndex(contentWidth, contentHeight) {\n    if (contentWidth > 0 && contentHeight > 0 && this.props.initialScrollIndex != null && this.props.initialScrollIndex > 0 && !this._hasTriggeredInitialScrollToIndex) {\n      if (this.props.contentOffset == null) {\n        if (this.props.initialScrollIndex < this.props.getItemCount(this.props.data)) {\n          this.scrollToIndex({\n            animated: false,\n            index: nullthrows(this.props.initialScrollIndex)\n          });\n        } else {\n          this.scrollToEnd({\n            animated: false\n          });\n        }\n      }\n      this._hasTriggeredInitialScrollToIndex = true;\n    }\n  }\n  _offsetFromScrollEvent(e) {\n    const {\n      contentOffset,\n      contentSize,\n      layoutMeasurement\n    } = e.nativeEvent;\n    const {\n      horizontal,\n      rtl\n    } = this._orientation();\n    if (horizontal && rtl) {\n      return this._selectLength(contentSize) - (this._selectOffset(contentOffset) + this._selectLength(layoutMeasurement));\n    } else {\n      return this._selectOffset(contentOffset);\n    }\n  }\n  _scheduleCellsToRenderUpdate() {\n    if ((this._listMetrics.getAverageCellLength() > 0 || this.props.getItemLayout != null) && this._shouldRenderWithPriority() && !this._hiPriInProgress) {\n      this._hiPriInProgress = true;\n      this._updateCellsToRenderBatcher.dispose({\n        abort: true\n      });\n      this._updateCellsToRender();\n      return;\n    } else {\n      this._updateCellsToRenderBatcher.schedule();\n    }\n  }\n  _shouldRenderWithPriority() {\n    const {\n      first,\n      last\n    } = this.state.cellsAroundViewport;\n    const {\n      offset,\n      visibleLength,\n      velocity\n    } = this._scrollMetrics;\n    const itemCount = this.props.getItemCount(this.props.data);\n    let hiPri = false;\n    const onStartReachedThreshold = onStartReachedThresholdOrDefault(this.props.onStartReachedThreshold);\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(this.props.onEndReachedThreshold);\n    if (first > 0) {\n      const distTop = offset - this._listMetrics.getCellMetricsApprox(first, this.props).offset;\n      hiPri = distTop < 0 || velocity < -2 && distTop < getScrollingThreshold(onStartReachedThreshold, visibleLength);\n    }\n    if (!hiPri && last >= 0 && last < itemCount - 1) {\n      const distBottom = this._listMetrics.getCellMetricsApprox(last, this.props).offset - (offset + visibleLength);\n      hiPri = distBottom < 0 || velocity > 2 && distBottom < getScrollingThreshold(onEndReachedThreshold, visibleLength);\n    }\n    return hiPri;\n  }\n  __getListMetrics() {\n    return this._listMetrics;\n  }\n  _updateViewableItems(props, cellsAroundViewport) {\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.onUpdate(props, this._scrollMetrics.offset, this._scrollMetrics.visibleLength, this._listMetrics, this._createViewToken, tuple.onViewableItemsChanged, cellsAroundViewport);\n    });\n  }\n}\nVirtualizedList.contextType = VirtualizedListContext;\nconst styles = StyleSheet.create({\n  verticallyInverted: Platform.OS === 'android' ? {\n    transform: [{\n      scale: -1\n    }]\n  } : {\n    transform: [{\n      scaleY: -1\n    }]\n  },\n  horizontallyInverted: {\n    transform: [{\n      scaleX: -1\n    }]\n  },\n  debug: {\n    flex: 1\n  },\n  debugOverlayBase: {\n    position: 'absolute',\n    top: 0,\n    right: 0\n  },\n  debugOverlay: {\n    bottom: 0,\n    width: 20,\n    borderColor: 'blue',\n    borderWidth: 1\n  },\n  debugOverlayFrame: {\n    left: 0,\n    backgroundColor: 'orange'\n  },\n  debugOverlayFrameLast: {\n    left: 0,\n    borderColor: 'green',\n    borderWidth: 2\n  },\n  debugOverlayFrameVis: {\n    left: 0,\n    borderColor: 'red',\n    borderWidth: 2\n  }\n});\nmodule.exports = VirtualizedList;","map":{"version":3,"names":["Batchinator","clamp","infoLog","CellRenderMask","ChildListCollection","FillRateHelper","ListMetricsAggregator","StateSafePureComponent","ViewabilityHelper","CellRenderer","VirtualizedListCellContextProvider","VirtualizedListContext","VirtualizedListContextProvider","horizontalOrDefault","initialNumToRenderOrDefault","maxToRenderPerBatchOrDefault","onEndReachedThresholdOrDefault","onStartReachedThresholdOrDefault","windowSizeOrDefault","computeWindowedRenderLimits","keyExtractor","defaultKeyExtractor","invariant","nullthrows","React","I18nManager","Platform","RefreshControl","ScrollView","StyleSheet","View","findNodeHandle","jsxDEV","_jsxDEV","ON_EDGE_REACHED_EPSILON","_usedIndexForKey","_keylessItemComponentName","getScrollingThreshold","threshold","visibleLength","VirtualizedList","scrollToEnd","params","animated","veryLast","props","getItemCount","data","frame","_listMetrics","getCellMetricsApprox","offset","Math","max","length","_footerLength","_scrollMetrics","scrollToOffset","scrollToIndex","getItemLayout","onScrollToIndexFailed","index","viewOffset","viewPosition","getHighestMeasuredCellIndex","averageItemLength","getAverageCellLength","highestMeasuredFrameIndex","floor","getCellOffsetApprox","scrollToItem","item","getItem","itemCount","Object","assign","scrollRef","_scrollRef","scrollTo","console","warn","horizontal","rtl","_orientation","hasContentLength","_scrollToParamsFromOffset","cartOffset","cartesianOffset","x","y","recordInteraction","_nestedChildLists","forEach","childList","_viewabilityTuples","t","viewabilityHelper","_updateViewableItems","state","cellsAroundViewport","flashScrollIndicators","getScrollResponder","getScrollableNode","getScrollRef","setNativeProps","_getCellKey","context","cellKey","hasMore","_hasMore","constructor","_getScrollMetrics","_getOutermostParentListRef","_isNestedWithSameOrientation","getOutermostParentListRef","_registerAsNestedChild","add","ref","_hasInteracted","_unregisterAsNestedChild","remove","_onUpdateSeparators","keys","newProps","key","_cellRefs","updateSeparatorProps","_getSpacerKey","isVertical","_fillRateHelper","_hasTriggeredInitialScrollToIndex","_hasWarned","_headerLength","_hiPriInProgress","_indicesToKeys","Map","_lastFocusedCellKey","_offsetFromParentVirtualizedList","_pendingViewabilityUpdate","_prevParentOffset","dOffset","dt","timestamp","velocity","zoomScale","_sentStartForContentLength","_sentEndForContentLength","_updateCellsToRenderBatcher","_captureScrollRef","_defaultRenderScrollComponent","onRefresh","otherProps","_objectWithoutPropertiesLoose","_excluded","fileName","_jsxFileName","lineNumber","columnNumber","refreshing","JSON","stringify","refreshControl","progressViewOffset","_onCellLayout","e","cellIndex","layoutHasChanged","notifyCellLayout","layout","nativeEvent","orientation","_scheduleCellsToRenderUpdate","_triggerRemeasureForChildListsInCell","_computeBlankness","_onCellFocusCapture","_updateCellsToRender","_onCellUnmount","notifyCellUnmounted","_onLayout","measureLayoutRelativeToContainingList","_selectLength","onLayout","_maybeCallOnEdgeReached","_onLayoutEmpty","_onLayoutFooter","_getFooterCellKey","_onLayoutHeader","_onContentSizeChange","width","height","notifyListContentLayout","_maybeScrollToInitialScrollIndex","onContentSizeChange","_convertParentScrollMetrics","metrics","contentLength","getContentLength","_onScroll","onScroll","timeStamp","layoutMeasurement","contentSize","_offsetFromScrollEvent","perf","prevDt","pendingScrollUpdateCount","setState","activate","_onScrollBeginDrag","tuple","onScrollBeginDrag","_onScrollEndDrag","_selectOffset","onScrollEndDrag","_onMomentumScrollBegin","onMomentumScrollBegin","_onMomentumScrollEnd","onMomentumScrollEnd","_adjustCellsAroundViewport","renderMask","_createRenderMask","_getNonViewportRenderRegions","first","last","equals","_createViewToken","isViewable","_keyExtractor","lastFocusedCellRenderer","focusedCellIndex","_getItemKey","heightOfCellsBeforeFocused","i","heightOfCellsAfterFocused","_checkProps","updateCellsBatchingPeriod","viewabilityConfigCallbackPairs","map","pair","viewabilityConfig","onViewableItemsChanged","push","initialRenderRegion","_initialRenderRegion","minIndexForVisible","maintainVisibleContentPosition","firstVisibleItemKey","initialScrollIndex","windowSize","__isNative","__DEV__","flexWrap","flatStyles","flatten","contentContainerStyle","_findItemIndexWithKey","hint","curKey","ii","additionalRegions","allRegions","region","addCells","initialRegion","stickyIndicesSet","Set","stickyHeaderIndices","_ensureClosestStickyHeader","firstCellIndex","min","lastCellIndex","initialNumToRender","cellIdx","stickyOffset","ListHeaderComponent","itemIdx","has","onEndReachedThreshold","distanceFromEnd","_constrainToItemCount","newCellsAroundViewport","disableVirtualization","renderAhead","maxToRenderPerBatch","size","childIdx","_findFirstChildWithMore","cellKeyForIndex","get","anyInCell","componentDidMount","registerAsNestedChild","componentWillUnmount","unregisterAsNestedChild","dispose","abort","deactivateAndFlush","getDerivedStateFromProps","prevState","numCells","maintainVisibleContentPositionAdjustment","prevFirstVisibleItemKey","newFirstVisibleItemKey","firstVisibleItemIndex","constrainedCells","_pushCells","cells","stickyIndicesFromProps","inversionStyle","CellRendererComponent","ItemSeparatorComponent","ListItemComponent","debug","renderItem","end","prevCellKey","set","shouldListenForLayout","enabled","undefined","onUpdateSeparators","onCellFocusCapture","onUnmount","onCellLayout","lastPossibleCellIndex","maxFirst","nestedContext","String","type","displayName","render","ListEmptyComponent","ListFooterComponent","inverted","styles","horizontallyInverted","verticallyInverted","element","isValidElement","children","collapsable","style","compose","ListHeaderComponentStyle","cloneElement","event","spacerKey","renderRegions","enumerateRegions","lastRegion","lastSpacer","isSpacer","section","isLastSpacer","constrainToMeasured","firstMetrics","lastMetrics","spacerSize","ListFooterComponentStyle","scrollProps","scrollEventThrottle","invertStickyHeaders","isInvertedVirtualizedList","innerRet","value","getScrollMetrics","renderScrollComponent","ret","Context","Consumer","scrollContext","nesting","scrollEnabled","error","_renderDebugOverlay","componentDidUpdate","prevProps","extraData","resetViewableIndices","hiPriInProgress","computeBlankness","forEachInCell","measureLayout","scrollMetrics","metricsChanged","stack","normalize","framesInLayout","isMounted","windowTop","frameLast","windowLen","visTop","visLen","debugOverlayBase","debugOverlay","f","debugOverlayFrame","top","debugOverlayFrameLast","debugOverlayFrameVis","isRTL","onStartReached","onStartReachedThreshold","onEndReached","distanceFromStart","DEFAULT_THRESHOLD_PX","startThreshold","endThreshold","isWithinStartThreshold","isWithinEndThreshold","contentWidth","contentHeight","contentOffset","_shouldRenderWithPriority","schedule","hiPri","distTop","distBottom","__getListMetrics","onUpdate","contextType","create","OS","transform","scale","scaleY","scaleX","flex","position","right","bottom","borderColor","borderWidth","left","backgroundColor","module","exports"],"sources":["F:/MiniProject/node_modules/@react-native/virtualized-lists/Lists/VirtualizedList.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\nimport type {CellMetricProps, ListOrientation} from './ListMetricsAggregator';\nimport type {ViewToken} from './ViewabilityHelper';\nimport type {\n  Item,\n  Props,\n  RenderItemProps,\n  RenderItemType,\n  Separators,\n} from './VirtualizedListProps';\nimport type {ScrollResponderType} from 'react-native/Libraries/Components/ScrollView/ScrollView';\nimport type {ViewStyleProp} from 'react-native/Libraries/StyleSheet/StyleSheet';\nimport type {\n  LayoutEvent,\n  ScrollEvent,\n} from 'react-native/Libraries/Types/CoreEventTypes';\n\nimport Batchinator from '../Interaction/Batchinator';\nimport clamp from '../Utilities/clamp';\nimport infoLog from '../Utilities/infoLog';\nimport {CellRenderMask} from './CellRenderMask';\nimport ChildListCollection from './ChildListCollection';\nimport FillRateHelper from './FillRateHelper';\nimport ListMetricsAggregator from './ListMetricsAggregator';\nimport StateSafePureComponent from './StateSafePureComponent';\nimport ViewabilityHelper from './ViewabilityHelper';\nimport CellRenderer from './VirtualizedListCellRenderer';\nimport {\n  VirtualizedListCellContextProvider,\n  VirtualizedListContext,\n  VirtualizedListContextProvider,\n} from './VirtualizedListContext.js';\nimport {\n  horizontalOrDefault,\n  initialNumToRenderOrDefault,\n  maxToRenderPerBatchOrDefault,\n  onEndReachedThresholdOrDefault,\n  onStartReachedThresholdOrDefault,\n  windowSizeOrDefault,\n} from './VirtualizedListProps';\nimport {\n  computeWindowedRenderLimits,\n  keyExtractor as defaultKeyExtractor,\n} from './VirtualizeUtils';\nimport invariant from 'invariant';\nimport nullthrows from 'nullthrows';\nimport * as React from 'react';\nimport {\n  I18nManager,\n  Platform,\n  RefreshControl,\n  ScrollView,\n  StyleSheet,\n  View,\n  findNodeHandle,\n} from 'react-native';\n\nexport type {RenderItemProps, RenderItemType, Separators};\n\nconst ON_EDGE_REACHED_EPSILON = 0.001;\n\nlet _usedIndexForKey = false;\nlet _keylessItemComponentName: string = '';\n\ntype ViewabilityHelperCallbackTuple = {\n  viewabilityHelper: ViewabilityHelper,\n  onViewableItemsChanged: (info: {\n    viewableItems: Array<ViewToken>,\n    changed: Array<ViewToken>,\n    ...\n  }) => void,\n  ...\n};\n\ntype State = {\n  renderMask: CellRenderMask,\n  cellsAroundViewport: {first: number, last: number},\n  // Used to track items added at the start of the list for maintainVisibleContentPosition.\n  firstVisibleItemKey: ?string,\n  // When > 0 the scroll position available in JS is considered stale and should not be used.\n  pendingScrollUpdateCount: number,\n};\n\nfunction getScrollingThreshold(threshold: number, visibleLength: number) {\n  return (threshold * visibleLength) / 2;\n}\n\n/**\n * Base implementation for the more convenient [`<FlatList>`](https://reactnative.dev/docs/flatlist)\n * and [`<SectionList>`](https://reactnative.dev/docs/sectionlist) components, which are also better\n * documented. In general, this should only really be used if you need more flexibility than\n * `FlatList` provides, e.g. for use with immutable data instead of plain arrays.\n *\n * Virtualization massively improves memory consumption and performance of large lists by\n * maintaining a finite render window of active items and replacing all items outside of the render\n * window with appropriately sized blank space. The window adapts to scrolling behavior, and items\n * are rendered incrementally with low-pri (after any running interactions) if they are far from the\n * visible area, or with hi-pri otherwise to minimize the potential of seeing blank space.\n *\n * Some caveats:\n *\n * - Internal state is not preserved when content scrolls out of the render window. Make sure all\n *   your data is captured in the item data or external stores like Flux, Redux, or Relay.\n * - This is a `PureComponent` which means that it will not re-render if `props` remain shallow-\n *   equal. Make sure that everything your `renderItem` function depends on is passed as a prop\n *   (e.g. `extraData`) that is not `===` after updates, otherwise your UI may not update on\n *   changes. This includes the `data` prop and parent component state.\n * - In order to constrain memory and enable smooth scrolling, content is rendered asynchronously\n *   offscreen. This means it's possible to scroll faster than the fill rate ands momentarily see\n *   blank content. This is a tradeoff that can be adjusted to suit the needs of each application,\n *   and we are working on improving it behind the scenes.\n * - By default, the list looks for a `key` or `id` prop on each item and uses that for the React key.\n *   Alternatively, you can provide a custom `keyExtractor` prop.\n * - As an effort to remove defaultProps, use helper functions when referencing certain props\n *\n */\nclass VirtualizedList extends StateSafePureComponent<Props, State> {\n  static contextType: typeof VirtualizedListContext = VirtualizedListContext;\n\n  // scrollToEnd may be janky without getItemLayout prop\n  scrollToEnd(params?: ?{animated?: ?boolean, ...}) {\n    const animated = params ? params.animated : true;\n    const veryLast = this.props.getItemCount(this.props.data) - 1;\n    if (veryLast < 0) {\n      return;\n    }\n    const frame = this._listMetrics.getCellMetricsApprox(veryLast, this.props);\n    const offset = Math.max(\n      0,\n      frame.offset +\n        frame.length +\n        this._footerLength -\n        this._scrollMetrics.visibleLength,\n    );\n\n    // TODO: consider using `ref.scrollToEnd` directly\n    this.scrollToOffset({animated, offset});\n  }\n\n  // scrollToIndex may be janky without getItemLayout prop\n  scrollToIndex(params: {\n    animated?: ?boolean,\n    index: number,\n    viewOffset?: number,\n    viewPosition?: number,\n    ...\n  }): $FlowFixMe {\n    const {data, getItemCount, getItemLayout, onScrollToIndexFailed} =\n      this.props;\n    const {animated, index, viewOffset, viewPosition} = params;\n    invariant(\n      index >= 0,\n      `scrollToIndex out of range: requested index ${index} but minimum is 0`,\n    );\n    invariant(\n      getItemCount(data) >= 1,\n      `scrollToIndex out of range: item length ${getItemCount(\n        data,\n      )} but minimum is 1`,\n    );\n    invariant(\n      index < getItemCount(data),\n      `scrollToIndex out of range: requested index ${index} is out of 0 to ${\n        getItemCount(data) - 1\n      }`,\n    );\n    if (\n      !getItemLayout &&\n      index > this._listMetrics.getHighestMeasuredCellIndex()\n    ) {\n      invariant(\n        !!onScrollToIndexFailed,\n        'scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, ' +\n          'otherwise there is no way to know the location of offscreen indices or handle failures.',\n      );\n      onScrollToIndexFailed({\n        averageItemLength: this._listMetrics.getAverageCellLength(),\n        highestMeasuredFrameIndex:\n          this._listMetrics.getHighestMeasuredCellIndex(),\n        index,\n      });\n      return;\n    }\n    const frame = this._listMetrics.getCellMetricsApprox(\n      Math.floor(index),\n      this.props,\n    );\n    const offset =\n      Math.max(\n        0,\n        this._listMetrics.getCellOffsetApprox(index, this.props) -\n          (viewPosition || 0) *\n            (this._scrollMetrics.visibleLength - frame.length),\n      ) - (viewOffset || 0);\n\n    this.scrollToOffset({offset, animated});\n  }\n\n  // scrollToItem may be janky without getItemLayout prop. Required linear scan through items -\n  // use scrollToIndex instead if possible.\n  scrollToItem(params: {\n    animated?: ?boolean,\n    item: Item,\n    viewOffset?: number,\n    viewPosition?: number,\n    ...\n  }) {\n    const {item} = params;\n    const {data, getItem, getItemCount} = this.props;\n    const itemCount = getItemCount(data);\n    for (let index = 0; index < itemCount; index++) {\n      if (getItem(data, index) === item) {\n        this.scrollToIndex({...params, index});\n        break;\n      }\n    }\n  }\n\n  /**\n   * Scroll to a specific content pixel offset in the list.\n   *\n   * Param `offset` expects the offset to scroll to.\n   * In case of `horizontal` is true, the offset is the x-value,\n   * in any other case the offset is the y-value.\n   *\n   * Param `animated` (`true` by default) defines whether the list\n   * should do an animation while scrolling.\n   */\n  scrollToOffset(params: {animated?: ?boolean, offset: number, ...}) {\n    const {animated, offset} = params;\n    const scrollRef = this._scrollRef;\n\n    if (scrollRef == null) {\n      return;\n    }\n\n    if (scrollRef.scrollTo == null) {\n      console.warn(\n        'No scrollTo method provided. This may be because you have two nested ' +\n          'VirtualizedLists with the same orientation, or because you are ' +\n          'using a custom component that does not implement scrollTo.',\n      );\n      return;\n    }\n\n    const {horizontal, rtl} = this._orientation();\n    if (horizontal && rtl && !this._listMetrics.hasContentLength()) {\n      console.warn(\n        'scrollToOffset may not be called in RTL before content is laid out',\n      );\n      return;\n    }\n\n    scrollRef.scrollTo({\n      animated,\n      ...this._scrollToParamsFromOffset(offset),\n    });\n  }\n\n  _scrollToParamsFromOffset(offset: number): {x?: number, y?: number} {\n    const {horizontal, rtl} = this._orientation();\n    if (horizontal && rtl) {\n      // Add the visible length of the scrollview so that the offset is right-aligned\n      const cartOffset = this._listMetrics.cartesianOffset(\n        offset + this._scrollMetrics.visibleLength,\n      );\n      return horizontal ? {x: cartOffset} : {y: cartOffset};\n    } else {\n      return horizontal ? {x: offset} : {y: offset};\n    }\n  }\n\n  recordInteraction() {\n    this._nestedChildLists.forEach(childList => {\n      childList.recordInteraction();\n    });\n    this._viewabilityTuples.forEach(t => {\n      t.viewabilityHelper.recordInteraction();\n    });\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  }\n\n  flashScrollIndicators() {\n    if (this._scrollRef == null) {\n      return;\n    }\n\n    this._scrollRef.flashScrollIndicators();\n  }\n\n  /**\n   * Provides a handle to the underlying scroll responder.\n   * Note that `this._scrollRef` might not be a `ScrollView`, so we\n   * need to check that it responds to `getScrollResponder` before calling it.\n   */\n  getScrollResponder(): ?ScrollResponderType {\n    if (this._scrollRef && this._scrollRef.getScrollResponder) {\n      return this._scrollRef.getScrollResponder();\n    }\n  }\n\n  getScrollableNode(): ?number {\n    if (this._scrollRef && this._scrollRef.getScrollableNode) {\n      return this._scrollRef.getScrollableNode();\n    } else {\n      return findNodeHandle(this._scrollRef);\n    }\n  }\n\n  getScrollRef():\n    | ?React.ElementRef<typeof ScrollView>\n    | ?React.ElementRef<typeof View> {\n    if (this._scrollRef && this._scrollRef.getScrollRef) {\n      return this._scrollRef.getScrollRef();\n    } else {\n      return this._scrollRef;\n    }\n  }\n\n  setNativeProps(props: Object) {\n    if (this._scrollRef) {\n      this._scrollRef.setNativeProps(props);\n    }\n  }\n\n  _getCellKey(): string {\n    return this.context?.cellKey || 'rootList';\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _getScrollMetrics = () => {\n    return this._scrollMetrics;\n  };\n\n  hasMore(): boolean {\n    return this._hasMore;\n  }\n\n  // $FlowFixMe[missing-local-annot]\n  _getOutermostParentListRef = () => {\n    if (this._isNestedWithSameOrientation()) {\n      return this.context.getOutermostParentListRef();\n    } else {\n      return this;\n    }\n  };\n\n  _registerAsNestedChild = (childList: {\n    cellKey: string,\n    ref: React.ElementRef<typeof VirtualizedList>,\n  }): void => {\n    this._nestedChildLists.add(childList.ref, childList.cellKey);\n    if (this._hasInteracted) {\n      childList.ref.recordInteraction();\n    }\n  };\n\n  _unregisterAsNestedChild = (childList: {\n    ref: React.ElementRef<typeof VirtualizedList>,\n  }): void => {\n    this._nestedChildLists.remove(childList.ref);\n  };\n\n  state: State;\n\n  constructor(props: Props) {\n    super(props);\n    this._checkProps(props);\n\n    this._fillRateHelper = new FillRateHelper(this._listMetrics);\n    this._updateCellsToRenderBatcher = new Batchinator(\n      this._updateCellsToRender,\n      this.props.updateCellsBatchingPeriod ?? 50,\n    );\n\n    if (this.props.viewabilityConfigCallbackPairs) {\n      this._viewabilityTuples = this.props.viewabilityConfigCallbackPairs.map(\n        pair => ({\n          viewabilityHelper: new ViewabilityHelper(pair.viewabilityConfig),\n          onViewableItemsChanged: pair.onViewableItemsChanged,\n        }),\n      );\n    } else {\n      const {onViewableItemsChanged, viewabilityConfig} = this.props;\n      if (onViewableItemsChanged) {\n        this._viewabilityTuples.push({\n          viewabilityHelper: new ViewabilityHelper(viewabilityConfig),\n          onViewableItemsChanged: onViewableItemsChanged,\n        });\n      }\n    }\n\n    const initialRenderRegion = VirtualizedList._initialRenderRegion(props);\n\n    const minIndexForVisible =\n      this.props.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n\n    this.state = {\n      cellsAroundViewport: initialRenderRegion,\n      renderMask: VirtualizedList._createRenderMask(props, initialRenderRegion),\n      firstVisibleItemKey:\n        this.props.getItemCount(this.props.data) > minIndexForVisible\n          ? VirtualizedList._getItemKey(this.props, minIndexForVisible)\n          : null,\n      // When we have a non-zero initialScrollIndex, we will receive a\n      // scroll event later so this will prevent the window from updating\n      // until we get a valid offset.\n      pendingScrollUpdateCount:\n        this.props.initialScrollIndex != null &&\n        this.props.initialScrollIndex > 0\n          ? 1\n          : 0,\n    };\n  }\n\n  _checkProps(props: Props) {\n    const {onScroll, windowSize, getItemCount, data, initialScrollIndex} =\n      props;\n\n    invariant(\n      // $FlowFixMe[prop-missing]\n      !onScroll || !onScroll.__isNative,\n      'Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent ' +\n        'to support native onScroll events with useNativeDriver',\n    );\n    invariant(\n      windowSizeOrDefault(windowSize) > 0,\n      'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.',\n    );\n\n    invariant(\n      getItemCount,\n      'VirtualizedList: The \"getItemCount\" prop must be provided',\n    );\n\n    const itemCount = getItemCount(data);\n\n    if (\n      initialScrollIndex != null &&\n      !this._hasTriggeredInitialScrollToIndex &&\n      (initialScrollIndex < 0 ||\n        (itemCount > 0 && initialScrollIndex >= itemCount)) &&\n      !this._hasWarned.initialScrollIndex\n    ) {\n      console.warn(\n        `initialScrollIndex \"${initialScrollIndex}\" is not valid (list has ${itemCount} items)`,\n      );\n      this._hasWarned.initialScrollIndex = true;\n    }\n\n    if (__DEV__ && !this._hasWarned.flexWrap) {\n      // $FlowFixMe[underconstrained-implicit-instantiation]\n      const flatStyles = StyleSheet.flatten(this.props.contentContainerStyle);\n      if (flatStyles != null && flatStyles.flexWrap === 'wrap') {\n        console.warn(\n          '`flexWrap: `wrap`` is not supported with the `VirtualizedList` components.' +\n            'Consider using `numColumns` with `FlatList` instead.',\n        );\n        this._hasWarned.flexWrap = true;\n      }\n    }\n  }\n\n  static _findItemIndexWithKey(\n    props: Props,\n    key: string,\n    hint: ?number,\n  ): ?number {\n    const itemCount = props.getItemCount(props.data);\n    if (hint != null && hint >= 0 && hint < itemCount) {\n      const curKey = VirtualizedList._getItemKey(props, hint);\n      if (curKey === key) {\n        return hint;\n      }\n    }\n    for (let ii = 0; ii < itemCount; ii++) {\n      const curKey = VirtualizedList._getItemKey(props, ii);\n      if (curKey === key) {\n        return ii;\n      }\n    }\n    return null;\n  }\n\n  static _getItemKey(\n    props: {\n      data: Props['data'],\n      getItem: Props['getItem'],\n      keyExtractor: Props['keyExtractor'],\n      ...\n    },\n    index: number,\n  ): string {\n    const item = props.getItem(props.data, index);\n    return VirtualizedList._keyExtractor(item, index, props);\n  }\n\n  static _createRenderMask(\n    props: Props,\n    cellsAroundViewport: {first: number, last: number},\n    additionalRegions?: ?$ReadOnlyArray<{first: number, last: number}>,\n  ): CellRenderMask {\n    const itemCount = props.getItemCount(props.data);\n\n    invariant(\n      cellsAroundViewport.first >= 0 &&\n        cellsAroundViewport.last >= cellsAroundViewport.first - 1 &&\n        cellsAroundViewport.last < itemCount,\n      `Invalid cells around viewport \"[${cellsAroundViewport.first}, ${cellsAroundViewport.last}]\" was passed to VirtualizedList._createRenderMask`,\n    );\n\n    const renderMask = new CellRenderMask(itemCount);\n\n    if (itemCount > 0) {\n      const allRegions = [cellsAroundViewport, ...(additionalRegions ?? [])];\n      for (const region of allRegions) {\n        renderMask.addCells(region);\n      }\n\n      // The initially rendered cells are retained as part of the\n      // \"scroll-to-top\" optimization\n      if (props.initialScrollIndex == null || props.initialScrollIndex <= 0) {\n        const initialRegion = VirtualizedList._initialRenderRegion(props);\n        renderMask.addCells(initialRegion);\n      }\n\n      // The layout coordinates of sticker headers may be off-screen while the\n      // actual header is on-screen. Keep the most recent before the viewport\n      // rendered, even if its layout coordinates are not in viewport.\n      const stickyIndicesSet = new Set(props.stickyHeaderIndices);\n      VirtualizedList._ensureClosestStickyHeader(\n        props,\n        stickyIndicesSet,\n        renderMask,\n        cellsAroundViewport.first,\n      );\n    }\n\n    return renderMask;\n  }\n\n  static _initialRenderRegion(props: Props): {first: number, last: number} {\n    const itemCount = props.getItemCount(props.data);\n\n    const firstCellIndex = Math.max(\n      0,\n      Math.min(itemCount - 1, Math.floor(props.initialScrollIndex ?? 0)),\n    );\n\n    const lastCellIndex =\n      Math.min(\n        itemCount,\n        firstCellIndex + initialNumToRenderOrDefault(props.initialNumToRender),\n      ) - 1;\n\n    return {\n      first: firstCellIndex,\n      last: lastCellIndex,\n    };\n  }\n\n  static _ensureClosestStickyHeader(\n    props: Props,\n    stickyIndicesSet: Set<number>,\n    renderMask: CellRenderMask,\n    cellIdx: number,\n  ) {\n    const stickyOffset = props.ListHeaderComponent ? 1 : 0;\n\n    for (let itemIdx = cellIdx - 1; itemIdx >= 0; itemIdx--) {\n      if (stickyIndicesSet.has(itemIdx + stickyOffset)) {\n        renderMask.addCells({first: itemIdx, last: itemIdx});\n        break;\n      }\n    }\n  }\n\n  _adjustCellsAroundViewport(\n    props: Props,\n    cellsAroundViewport: {first: number, last: number},\n    pendingScrollUpdateCount: number,\n  ): {first: number, last: number} {\n    const {data, getItemCount} = props;\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(\n      props.onEndReachedThreshold,\n    );\n    const {offset, visibleLength} = this._scrollMetrics;\n    const contentLength = this._listMetrics.getContentLength();\n    const distanceFromEnd = contentLength - visibleLength - offset;\n\n    // Wait until the scroll view metrics have been set up. And until then,\n    // we will trust the initialNumToRender suggestion\n    if (visibleLength <= 0 || contentLength <= 0) {\n      return cellsAroundViewport.last >= getItemCount(data)\n        ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props)\n        : cellsAroundViewport;\n    }\n\n    let newCellsAroundViewport: {first: number, last: number};\n    if (props.disableVirtualization) {\n      const renderAhead =\n        distanceFromEnd < onEndReachedThreshold * visibleLength\n          ? maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch)\n          : 0;\n\n      newCellsAroundViewport = {\n        first: 0,\n        last: Math.min(\n          cellsAroundViewport.last + renderAhead,\n          getItemCount(data) - 1,\n        ),\n      };\n    } else {\n      // If we have a pending scroll update, we should not adjust the render window as it\n      // might override the correct window.\n      if (pendingScrollUpdateCount > 0) {\n        return cellsAroundViewport.last >= getItemCount(data)\n          ? VirtualizedList._constrainToItemCount(cellsAroundViewport, props)\n          : cellsAroundViewport;\n      }\n\n      newCellsAroundViewport = computeWindowedRenderLimits(\n        props,\n        maxToRenderPerBatchOrDefault(props.maxToRenderPerBatch),\n        windowSizeOrDefault(props.windowSize),\n        cellsAroundViewport,\n        this._listMetrics,\n        this._scrollMetrics,\n      );\n      invariant(\n        newCellsAroundViewport.last < getItemCount(data),\n        'computeWindowedRenderLimits() should return range in-bounds',\n      );\n    }\n\n    if (this._nestedChildLists.size() > 0) {\n      // If some cell in the new state has a child list in it, we should only render\n      // up through that item, so that we give that list a chance to render.\n      // Otherwise there's churn from multiple child lists mounting and un-mounting\n      // their items.\n\n      // Will this prevent rendering if the nested list doesn't realize the end?\n      const childIdx = this._findFirstChildWithMore(\n        newCellsAroundViewport.first,\n        newCellsAroundViewport.last,\n      );\n\n      newCellsAroundViewport.last = childIdx ?? newCellsAroundViewport.last;\n    }\n\n    return newCellsAroundViewport;\n  }\n\n  _findFirstChildWithMore(first: number, last: number): number | null {\n    for (let ii = first; ii <= last; ii++) {\n      const cellKeyForIndex = this._indicesToKeys.get(ii);\n      if (\n        cellKeyForIndex != null &&\n        this._nestedChildLists.anyInCell(cellKeyForIndex, childList =>\n          childList.hasMore(),\n        )\n      ) {\n        return ii;\n      }\n    }\n\n    return null;\n  }\n\n  componentDidMount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.registerAsNestedChild({\n        ref: this,\n        cellKey: this.context.cellKey,\n      });\n    }\n  }\n\n  componentWillUnmount() {\n    if (this._isNestedWithSameOrientation()) {\n      this.context.unregisterAsNestedChild({ref: this});\n    }\n    this._updateCellsToRenderBatcher.dispose({abort: true});\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.dispose();\n    });\n    this._fillRateHelper.deactivateAndFlush();\n  }\n\n  static getDerivedStateFromProps(newProps: Props, prevState: State): State {\n    // first and last could be stale (e.g. if a new, shorter items props is passed in), so we make\n    // sure we're rendering a reasonable range here.\n    const itemCount = newProps.getItemCount(newProps.data);\n    if (itemCount === prevState.renderMask.numCells()) {\n      return prevState;\n    }\n\n    let maintainVisibleContentPositionAdjustment: ?number = null;\n    const prevFirstVisibleItemKey = prevState.firstVisibleItemKey;\n    const minIndexForVisible =\n      newProps.maintainVisibleContentPosition?.minIndexForVisible ?? 0;\n    const newFirstVisibleItemKey =\n      newProps.getItemCount(newProps.data) > minIndexForVisible\n        ? VirtualizedList._getItemKey(newProps, minIndexForVisible)\n        : null;\n    if (\n      newProps.maintainVisibleContentPosition != null &&\n      prevFirstVisibleItemKey != null &&\n      newFirstVisibleItemKey != null\n    ) {\n      if (newFirstVisibleItemKey !== prevFirstVisibleItemKey) {\n        // Fast path if items were added at the start of the list.\n        const hint =\n          itemCount - prevState.renderMask.numCells() + minIndexForVisible;\n        const firstVisibleItemIndex = VirtualizedList._findItemIndexWithKey(\n          newProps,\n          prevFirstVisibleItemKey,\n          hint,\n        );\n        maintainVisibleContentPositionAdjustment =\n          firstVisibleItemIndex != null\n            ? firstVisibleItemIndex - minIndexForVisible\n            : null;\n      } else {\n        maintainVisibleContentPositionAdjustment = null;\n      }\n    }\n\n    const constrainedCells = VirtualizedList._constrainToItemCount(\n      maintainVisibleContentPositionAdjustment != null\n        ? {\n            first:\n              prevState.cellsAroundViewport.first +\n              maintainVisibleContentPositionAdjustment,\n            last:\n              prevState.cellsAroundViewport.last +\n              maintainVisibleContentPositionAdjustment,\n          }\n        : prevState.cellsAroundViewport,\n      newProps,\n    );\n\n    return {\n      cellsAroundViewport: constrainedCells,\n      renderMask: VirtualizedList._createRenderMask(newProps, constrainedCells),\n      firstVisibleItemKey: newFirstVisibleItemKey,\n      pendingScrollUpdateCount:\n        maintainVisibleContentPositionAdjustment != null\n          ? prevState.pendingScrollUpdateCount + 1\n          : prevState.pendingScrollUpdateCount,\n    };\n  }\n\n  _pushCells(\n    cells: Array<Object>,\n    stickyHeaderIndices: Array<number>,\n    stickyIndicesFromProps: Set<number>,\n    first: number,\n    last: number,\n    inversionStyle: ViewStyleProp,\n  ) {\n    const {\n      CellRendererComponent,\n      ItemSeparatorComponent,\n      ListHeaderComponent,\n      ListItemComponent,\n      data,\n      debug,\n      getItem,\n      getItemCount,\n      getItemLayout,\n      horizontal,\n      renderItem,\n    } = this.props;\n    const stickyOffset = ListHeaderComponent ? 1 : 0;\n    const end = getItemCount(data) - 1;\n    let prevCellKey;\n    last = Math.min(end, last);\n\n    for (let ii = first; ii <= last; ii++) {\n      const item = getItem(data, ii);\n      const key = VirtualizedList._keyExtractor(item, ii, this.props);\n\n      this._indicesToKeys.set(ii, key);\n      if (stickyIndicesFromProps.has(ii + stickyOffset)) {\n        stickyHeaderIndices.push(cells.length);\n      }\n\n      const shouldListenForLayout =\n        getItemLayout == null || debug || this._fillRateHelper.enabled();\n\n      cells.push(\n        <CellRenderer\n          CellRendererComponent={CellRendererComponent}\n          ItemSeparatorComponent={ii < end ? ItemSeparatorComponent : undefined}\n          ListItemComponent={ListItemComponent}\n          cellKey={key}\n          horizontal={horizontal}\n          index={ii}\n          inversionStyle={inversionStyle}\n          item={item}\n          key={key}\n          prevCellKey={prevCellKey}\n          onUpdateSeparators={this._onUpdateSeparators}\n          onCellFocusCapture={this._onCellFocusCapture}\n          onUnmount={this._onCellUnmount}\n          ref={ref => {\n            this._cellRefs[key] = ref;\n          }}\n          renderItem={renderItem}\n          {...(shouldListenForLayout && {\n            onCellLayout: this._onCellLayout,\n          })}\n        />,\n      );\n      prevCellKey = key;\n    }\n  }\n\n  static _constrainToItemCount(\n    cells: {first: number, last: number},\n    props: Props,\n  ): {first: number, last: number} {\n    const itemCount = props.getItemCount(props.data);\n    const lastPossibleCellIndex = itemCount - 1;\n\n    // Constraining `last` may significantly shrink the window. Adjust `first`\n    // to expand the window if the new `last` results in a new window smaller\n    // than the number of cells rendered per batch.\n    const maxToRenderPerBatch = maxToRenderPerBatchOrDefault(\n      props.maxToRenderPerBatch,\n    );\n    const maxFirst = Math.max(0, lastPossibleCellIndex - maxToRenderPerBatch);\n\n    return {\n      first: clamp(0, cells.first, maxFirst),\n      last: Math.min(lastPossibleCellIndex, cells.last),\n    };\n  }\n\n  _onUpdateSeparators = (keys: Array<?string>, newProps: Object) => {\n    keys.forEach(key => {\n      const ref = key != null && this._cellRefs[key];\n      ref && ref.updateSeparatorProps(newProps);\n    });\n  };\n\n  _isNestedWithSameOrientation(): boolean {\n    const nestedContext = this.context;\n    return !!(\n      nestedContext &&\n      !!nestedContext.horizontal === horizontalOrDefault(this.props.horizontal)\n    );\n  }\n\n  _getSpacerKey = (isVertical: boolean): string =>\n    isVertical ? 'height' : 'width';\n\n  static _keyExtractor(\n    item: Item,\n    index: number,\n    props: {\n      keyExtractor?: ?(item: Item, index: number) => string,\n      ...\n    },\n  ): string {\n    if (props.keyExtractor != null) {\n      return props.keyExtractor(item, index);\n    }\n\n    const key = defaultKeyExtractor(item, index);\n    if (key === String(index)) {\n      _usedIndexForKey = true;\n      if (item.type && item.type.displayName) {\n        _keylessItemComponentName = item.type.displayName;\n      }\n    }\n    return key;\n  }\n\n  render(): React.Node {\n    this._checkProps(this.props);\n    const {ListEmptyComponent, ListFooterComponent, ListHeaderComponent} =\n      this.props;\n    const {data, horizontal} = this.props;\n    const inversionStyle = this.props.inverted\n      ? horizontalOrDefault(this.props.horizontal)\n        ? styles.horizontallyInverted\n        : styles.verticallyInverted\n      : null;\n    const cells: Array<any | React.Node> = [];\n    const stickyIndicesFromProps = new Set(this.props.stickyHeaderIndices);\n    const stickyHeaderIndices = [];\n\n    // 1. Add cell for ListHeaderComponent\n    if (ListHeaderComponent) {\n      if (stickyIndicesFromProps.has(0)) {\n        stickyHeaderIndices.push(0);\n      }\n      const element = React.isValidElement(ListHeaderComponent) ? (\n        ListHeaderComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListHeaderComponent />\n      );\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getCellKey() + '-header'}\n          key=\"$header\">\n          <View\n            // We expect that header component will be a single native view so make it\n            // not collapsable to avoid this view being flattened and make this assumption\n            // no longer true.\n            collapsable={false}\n            onLayout={this._onLayoutHeader}\n            style={StyleSheet.compose(\n              inversionStyle,\n              this.props.ListHeaderComponentStyle,\n            )}>\n            {\n              // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors\n              element\n            }\n          </View>\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 2a. Add a cell for ListEmptyComponent if applicable\n    const itemCount = this.props.getItemCount(data);\n    if (itemCount === 0 && ListEmptyComponent) {\n      const element: ExactReactElement_DEPRECATED<any> = ((React.isValidElement(\n        ListEmptyComponent,\n      ) ? (\n        ListEmptyComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListEmptyComponent />\n      )): any);\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getCellKey() + '-empty'}\n          key=\"$empty\">\n          {React.cloneElement(element, {\n            onLayout: (event: LayoutEvent) => {\n              this._onLayoutEmpty(event);\n              // $FlowFixMe[prop-missing] React.Element internal inspection\n              if (element.props.onLayout) {\n                element.props.onLayout(event);\n              }\n            },\n            // $FlowFixMe[prop-missing] React.Element internal inspection\n            style: StyleSheet.compose(inversionStyle, element.props.style),\n          })}\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 2b. Add cells and spacers for each item\n    if (itemCount > 0) {\n      _usedIndexForKey = false;\n      _keylessItemComponentName = '';\n      const spacerKey = this._getSpacerKey(!horizontal);\n\n      const renderRegions = this.state.renderMask.enumerateRegions();\n      const lastRegion = renderRegions[renderRegions.length - 1];\n      const lastSpacer = lastRegion?.isSpacer ? lastRegion : null;\n\n      for (const section of renderRegions) {\n        if (section.isSpacer) {\n          // Legacy behavior is to avoid spacers when virtualization is\n          // disabled (including head spacers on initial render).\n          if (this.props.disableVirtualization) {\n            continue;\n          }\n\n          // Without getItemLayout, we limit our tail spacer to the _highestMeasuredFrameIndex to\n          // prevent the user for hyperscrolling into un-measured area because otherwise content will\n          // likely jump around as it renders in above the viewport.\n          const isLastSpacer = section === lastSpacer;\n          const constrainToMeasured = isLastSpacer && !this.props.getItemLayout;\n          const last = constrainToMeasured\n            ? clamp(\n                section.first - 1,\n                section.last,\n                this._listMetrics.getHighestMeasuredCellIndex(),\n              )\n            : section.last;\n\n          const firstMetrics = this._listMetrics.getCellMetricsApprox(\n            section.first,\n            this.props,\n          );\n          const lastMetrics = this._listMetrics.getCellMetricsApprox(\n            last,\n            this.props,\n          );\n          const spacerSize =\n            lastMetrics.offset + lastMetrics.length - firstMetrics.offset;\n          cells.push(\n            <View\n              key={`$spacer-${section.first}`}\n              style={{[spacerKey]: spacerSize}}\n            />,\n          );\n        } else {\n          this._pushCells(\n            cells,\n            stickyHeaderIndices,\n            stickyIndicesFromProps,\n            section.first,\n            section.last,\n            inversionStyle,\n          );\n        }\n      }\n\n      if (!this._hasWarned.keys && _usedIndexForKey) {\n        console.warn(\n          'VirtualizedList: missing keys for items, make sure to specify a key or id property on each ' +\n            'item or provide a custom keyExtractor.',\n          _keylessItemComponentName,\n        );\n        this._hasWarned.keys = true;\n      }\n    }\n\n    // 3. Add cell for ListFooterComponent\n    if (ListFooterComponent) {\n      const element = React.isValidElement(ListFooterComponent) ? (\n        ListFooterComponent\n      ) : (\n        // $FlowFixMe[not-a-component]\n        // $FlowFixMe[incompatible-type-arg]\n        <ListFooterComponent />\n      );\n      cells.push(\n        <VirtualizedListCellContextProvider\n          cellKey={this._getFooterCellKey()}\n          key=\"$footer\">\n          <View\n            onLayout={this._onLayoutFooter}\n            style={StyleSheet.compose(\n              inversionStyle,\n              this.props.ListFooterComponentStyle,\n            )}>\n            {\n              // $FlowFixMe[incompatible-type] - Typing ReactNativeComponent revealed errors\n              element\n            }\n          </View>\n        </VirtualizedListCellContextProvider>,\n      );\n    }\n\n    // 4. Render the ScrollView\n    const scrollProps = {\n      ...this.props,\n      onContentSizeChange: this._onContentSizeChange,\n      onLayout: this._onLayout,\n      onScroll: this._onScroll,\n      onScrollBeginDrag: this._onScrollBeginDrag,\n      onScrollEndDrag: this._onScrollEndDrag,\n      onMomentumScrollBegin: this._onMomentumScrollBegin,\n      onMomentumScrollEnd: this._onMomentumScrollEnd,\n      // iOS/macOS requires a non-zero scrollEventThrottle to fire more than a\n      // single notification while scrolling. This will otherwise no-op.\n      scrollEventThrottle: this.props.scrollEventThrottle ?? 0.0001,\n      invertStickyHeaders:\n        this.props.invertStickyHeaders !== undefined\n          ? this.props.invertStickyHeaders\n          : this.props.inverted,\n      stickyHeaderIndices,\n      style: inversionStyle\n        ? [inversionStyle, this.props.style]\n        : this.props.style,\n      isInvertedVirtualizedList: this.props.inverted,\n      maintainVisibleContentPosition:\n        this.props.maintainVisibleContentPosition != null\n          ? {\n              ...this.props.maintainVisibleContentPosition,\n              // Adjust index to account for ListHeaderComponent.\n              minIndexForVisible:\n                this.props.maintainVisibleContentPosition.minIndexForVisible +\n                (this.props.ListHeaderComponent ? 1 : 0),\n            }\n          : undefined,\n    };\n\n    this._hasMore = this.state.cellsAroundViewport.last < itemCount - 1;\n\n    const innerRet = (\n      <VirtualizedListContextProvider\n        value={{\n          cellKey: null,\n          getScrollMetrics: this._getScrollMetrics,\n          horizontal: horizontalOrDefault(this.props.horizontal),\n          getOutermostParentListRef: this._getOutermostParentListRef,\n          registerAsNestedChild: this._registerAsNestedChild,\n          unregisterAsNestedChild: this._unregisterAsNestedChild,\n        }}>\n        {React.cloneElement(\n          (\n            this.props.renderScrollComponent ||\n            this._defaultRenderScrollComponent\n          )(scrollProps),\n          {\n            ref: this._captureScrollRef,\n          },\n          cells,\n        )}\n      </VirtualizedListContextProvider>\n    );\n    let ret: React.Node = innerRet;\n    if (__DEV__) {\n      ret = (\n        <ScrollView.Context.Consumer>\n          {scrollContext => {\n            if (\n              scrollContext != null &&\n              !scrollContext.horizontal ===\n                !horizontalOrDefault(this.props.horizontal) &&\n              !this._hasWarned.nesting &&\n              this.context == null &&\n              this.props.scrollEnabled !== false\n            ) {\n              console.error(\n                'VirtualizedLists should never be nested inside plain ScrollViews with the same ' +\n                  'orientation because it can break windowing and other functionality - use another ' +\n                  'VirtualizedList-backed container instead.',\n              );\n              this._hasWarned.nesting = true;\n            }\n            return innerRet;\n          }}\n        </ScrollView.Context.Consumer>\n      );\n    }\n    if (this.props.debug) {\n      return (\n        <View style={styles.debug}>\n          {ret}\n          {this._renderDebugOverlay()}\n        </View>\n      );\n    } else {\n      return ret;\n    }\n  }\n\n  componentDidUpdate(prevProps: Props) {\n    const {data, extraData} = this.props;\n    if (data !== prevProps.data || extraData !== prevProps.extraData) {\n      // clear the viewableIndices cache to also trigger\n      // the onViewableItemsChanged callback with the new data\n      this._viewabilityTuples.forEach(tuple => {\n        tuple.viewabilityHelper.resetViewableIndices();\n      });\n    }\n    // The `this._hiPriInProgress` is guaranteeing a hiPri cell update will only happen\n    // once per fiber update. The `_scheduleCellsToRenderUpdate` will set it to true\n    // if a hiPri update needs to perform. If `componentDidUpdate` is triggered with\n    // `this._hiPriInProgress=true`, means it's triggered by the hiPri update. The\n    // `_scheduleCellsToRenderUpdate` will check this condition and not perform\n    // another hiPri update.\n    const hiPriInProgress = this._hiPriInProgress;\n    this._scheduleCellsToRenderUpdate();\n    // Make sure setting `this._hiPriInProgress` back to false after `componentDidUpdate`\n    // is triggered with `this._hiPriInProgress = true`\n    if (hiPriInProgress) {\n      this._hiPriInProgress = false;\n    }\n  }\n\n  _cellRefs: {[string]: null | CellRenderer<any>} = {};\n  _fillRateHelper: FillRateHelper;\n  _listMetrics: ListMetricsAggregator = new ListMetricsAggregator();\n  _footerLength = 0;\n  // Used for preventing scrollToIndex from being called multiple times for initialScrollIndex\n  _hasTriggeredInitialScrollToIndex = false;\n  _hasInteracted = false;\n  _hasMore = false;\n  _hasWarned: {[string]: boolean} = {};\n  _headerLength = 0;\n  _hiPriInProgress: boolean = false; // flag to prevent infinite hiPri cell limit update\n  _indicesToKeys: Map<number, string> = new Map();\n  _lastFocusedCellKey: ?string = null;\n  _nestedChildLists: ChildListCollection<VirtualizedList> =\n    new ChildListCollection();\n  _offsetFromParentVirtualizedList: number = 0;\n  _pendingViewabilityUpdate: boolean = false;\n  _prevParentOffset: number = 0;\n  _scrollMetrics: {\n    dOffset: number,\n    dt: number,\n    offset: number,\n    timestamp: number,\n    velocity: number,\n    visibleLength: number,\n    zoomScale: number,\n  } = {\n    dOffset: 0,\n    dt: 10,\n    offset: 0,\n    timestamp: 0,\n    velocity: 0,\n    visibleLength: 0,\n    zoomScale: 1,\n  };\n  _scrollRef: ?React.ElementRef<any> = null;\n  _sentStartForContentLength = 0;\n  _sentEndForContentLength = 0;\n  _updateCellsToRenderBatcher: Batchinator;\n  _viewabilityTuples: Array<ViewabilityHelperCallbackTuple> = [];\n\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  _captureScrollRef = ref => {\n    this._scrollRef = ref;\n  };\n\n  _computeBlankness() {\n    this._fillRateHelper.computeBlankness(\n      this.props,\n      this.state.cellsAroundViewport,\n      this._scrollMetrics,\n    );\n  }\n\n  /* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n   * LTI update could not be added via codemod */\n  _defaultRenderScrollComponent = props => {\n    const onRefresh = props.onRefresh;\n    if (this._isNestedWithSameOrientation()) {\n      // Prevent VirtualizedList._onContentSizeChange from being triggered by a bubbling onContentSizeChange event.\n      // This could lead to internal inconsistencies within VirtualizedList.\n      const {onContentSizeChange, ...otherProps} = props;\n      return <View {...otherProps} />;\n    } else if (onRefresh) {\n      invariant(\n        typeof props.refreshing === 'boolean',\n        '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' +\n          JSON.stringify(props.refreshing ?? 'undefined') +\n          '`',\n      );\n      return (\n        // $FlowFixMe[prop-missing] Invalid prop usage\n        // $FlowFixMe[incompatible-use]\n        <ScrollView\n          {...props}\n          refreshControl={\n            props.refreshControl == null ? (\n              <RefreshControl\n                // $FlowFixMe[incompatible-type]\n                refreshing={props.refreshing}\n                onRefresh={onRefresh}\n                progressViewOffset={props.progressViewOffset}\n              />\n            ) : (\n              props.refreshControl\n            )\n          }\n        />\n      );\n    } else {\n      // $FlowFixMe[prop-missing] Invalid prop usage\n      // $FlowFixMe[incompatible-use]\n      return <ScrollView {...props} />;\n    }\n  };\n\n  _onCellLayout = (\n    e: LayoutEvent,\n    cellKey: string,\n    cellIndex: number,\n  ): void => {\n    const layoutHasChanged = this._listMetrics.notifyCellLayout({\n      cellIndex,\n      cellKey,\n      layout: e.nativeEvent.layout,\n      orientation: this._orientation(),\n    });\n\n    if (layoutHasChanged) {\n      this._scheduleCellsToRenderUpdate();\n    }\n\n    this._triggerRemeasureForChildListsInCell(cellKey);\n    this._computeBlankness();\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n  };\n\n  _onCellFocusCapture = (cellKey: string) => {\n    this._lastFocusedCellKey = cellKey;\n    this._updateCellsToRender();\n  };\n\n  _onCellUnmount = (cellKey: string) => {\n    delete this._cellRefs[cellKey];\n    this._listMetrics.notifyCellUnmounted(cellKey);\n  };\n\n  _triggerRemeasureForChildListsInCell(cellKey: string): void {\n    this._nestedChildLists.forEachInCell(cellKey, childList => {\n      childList.measureLayoutRelativeToContainingList();\n    });\n  }\n\n  measureLayoutRelativeToContainingList(): void {\n    // TODO (T35574538): findNodeHandle sometimes crashes with \"Unable to find\n    // node on an unmounted component\" during scrolling\n    try {\n      if (!this._scrollRef) {\n        return;\n      }\n      // We are assuming that getOutermostParentListRef().getScrollRef()\n      // is a non-null reference to a ScrollView\n      this._scrollRef.measureLayout(\n        this.context.getOutermostParentListRef().getScrollRef(),\n        (x, y, width, height) => {\n          this._offsetFromParentVirtualizedList = this._selectOffset({x, y});\n          this._listMetrics.notifyListContentLayout({\n            layout: {width, height},\n            orientation: this._orientation(),\n          });\n          const scrollMetrics = this._convertParentScrollMetrics(\n            this.context.getScrollMetrics(),\n          );\n\n          const metricsChanged =\n            this._scrollMetrics.visibleLength !== scrollMetrics.visibleLength ||\n            this._scrollMetrics.offset !== scrollMetrics.offset;\n\n          if (metricsChanged) {\n            this._scrollMetrics.visibleLength = scrollMetrics.visibleLength;\n            this._scrollMetrics.offset = scrollMetrics.offset;\n\n            // If metrics of the scrollView changed, then we triggered remeasure for child list\n            // to ensure VirtualizedList has the right information.\n            this._nestedChildLists.forEach(childList => {\n              childList.measureLayoutRelativeToContainingList();\n            });\n          }\n        },\n        error => {\n          console.warn(\n            \"VirtualizedList: Encountered an error while measuring a list's\" +\n              ' offset from its containing VirtualizedList.',\n          );\n        },\n      );\n    } catch (error) {\n      console.warn(\n        'measureLayoutRelativeToContainingList threw an error',\n        error.stack,\n      );\n    }\n  }\n\n  _onLayout = (e: LayoutEvent) => {\n    if (this._isNestedWithSameOrientation()) {\n      // Need to adjust our scroll metrics to be relative to our containing\n      // VirtualizedList before we can make claims about list item viewability\n      this.measureLayoutRelativeToContainingList();\n    } else {\n      this._scrollMetrics.visibleLength = this._selectLength(\n        e.nativeEvent.layout,\n      );\n    }\n    this.props.onLayout && this.props.onLayout(e);\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEdgeReached();\n  };\n\n  _onLayoutEmpty = (e: LayoutEvent) => {\n    this.props.onLayout && this.props.onLayout(e);\n  };\n\n  _getFooterCellKey(): string {\n    return this._getCellKey() + '-footer';\n  }\n\n  _onLayoutFooter = (e: LayoutEvent) => {\n    this._triggerRemeasureForChildListsInCell(this._getFooterCellKey());\n    this._footerLength = this._selectLength(e.nativeEvent.layout);\n  };\n\n  _onLayoutHeader = (e: LayoutEvent) => {\n    this._headerLength = this._selectLength(e.nativeEvent.layout);\n  };\n\n  // $FlowFixMe[missing-local-annot]\n  _renderDebugOverlay() {\n    const normalize =\n      this._scrollMetrics.visibleLength /\n      (this._listMetrics.getContentLength() || 1);\n    const framesInLayout = [];\n    const itemCount = this.props.getItemCount(this.props.data);\n    for (let ii = 0; ii < itemCount; ii++) {\n      const frame = this._listMetrics.getCellMetricsApprox(ii, this.props);\n      if (frame.isMounted) {\n        framesInLayout.push(frame);\n      }\n    }\n    const windowTop = this._listMetrics.getCellMetricsApprox(\n      this.state.cellsAroundViewport.first,\n      this.props,\n    ).offset;\n    const frameLast = this._listMetrics.getCellMetricsApprox(\n      this.state.cellsAroundViewport.last,\n      this.props,\n    );\n    const windowLen = frameLast.offset + frameLast.length - windowTop;\n    const visTop = this._scrollMetrics.offset;\n    const visLen = this._scrollMetrics.visibleLength;\n\n    return (\n      <View style={[styles.debugOverlayBase, styles.debugOverlay]}>\n        {framesInLayout.map((f, ii) => (\n          <View\n            key={'f' + ii}\n            style={[\n              styles.debugOverlayBase,\n              styles.debugOverlayFrame,\n              {\n                top: f.offset * normalize,\n                height: f.length * normalize,\n              },\n            ]}\n          />\n        ))}\n        <View\n          style={[\n            styles.debugOverlayBase,\n            styles.debugOverlayFrameLast,\n            {\n              top: windowTop * normalize,\n              height: windowLen * normalize,\n            },\n          ]}\n        />\n        <View\n          style={[\n            styles.debugOverlayBase,\n            styles.debugOverlayFrameVis,\n            {\n              top: visTop * normalize,\n              height: visLen * normalize,\n            },\n          ]}\n        />\n      </View>\n    );\n  }\n\n  _selectLength(\n    metrics: $ReadOnly<{\n      height: number,\n      width: number,\n      ...\n    }>,\n  ): number {\n    return !horizontalOrDefault(this.props.horizontal)\n      ? metrics.height\n      : metrics.width;\n  }\n\n  _selectOffset({x, y}: $ReadOnly<{x: number, y: number, ...}>): number {\n    return this._orientation().horizontal ? x : y;\n  }\n\n  _orientation(): ListOrientation {\n    return {\n      horizontal: horizontalOrDefault(this.props.horizontal),\n      rtl: I18nManager.isRTL,\n    };\n  }\n\n  _maybeCallOnEdgeReached() {\n    const {\n      data,\n      getItemCount,\n      onStartReached,\n      onStartReachedThreshold,\n      onEndReached,\n      onEndReachedThreshold,\n    } = this.props;\n    // If we have any pending scroll updates it means that the scroll metrics\n    // are out of date and we should not call any of the edge reached callbacks.\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n\n    const {visibleLength, offset} = this._scrollMetrics;\n    let distanceFromStart = offset;\n    let distanceFromEnd =\n      this._listMetrics.getContentLength() - visibleLength - offset;\n\n    // Especially when oERT is zero it's necessary to 'floor' very small distance values to be 0\n    // since debouncing causes us to not fire this event for every single \"pixel\" we scroll and can thus\n    // be at the edge of the list with a distance approximating 0 but not quite there.\n    if (distanceFromStart < ON_EDGE_REACHED_EPSILON) {\n      distanceFromStart = 0;\n    }\n    if (distanceFromEnd < ON_EDGE_REACHED_EPSILON) {\n      distanceFromEnd = 0;\n    }\n\n    // TODO: T121172172 Look into why we're \"defaulting\" to a threshold of 2px\n    // when oERT is not present (different from 2 viewports used elsewhere)\n    const DEFAULT_THRESHOLD_PX = 2;\n\n    const startThreshold =\n      onStartReachedThreshold != null\n        ? onStartReachedThreshold * visibleLength\n        : DEFAULT_THRESHOLD_PX;\n    const endThreshold =\n      onEndReachedThreshold != null\n        ? onEndReachedThreshold * visibleLength\n        : DEFAULT_THRESHOLD_PX;\n    const isWithinStartThreshold = distanceFromStart <= startThreshold;\n    const isWithinEndThreshold = distanceFromEnd <= endThreshold;\n\n    // First check if the user just scrolled within the end threshold\n    // and call onEndReached only once for a given content length,\n    // and only if onStartReached is not being executed\n    if (\n      onEndReached &&\n      this.state.cellsAroundViewport.last === getItemCount(data) - 1 &&\n      isWithinEndThreshold &&\n      this._listMetrics.getContentLength() !== this._sentEndForContentLength\n    ) {\n      this._sentEndForContentLength = this._listMetrics.getContentLength();\n      onEndReached({distanceFromEnd});\n    }\n\n    // Next check if the user just scrolled within the start threshold\n    // and call onStartReached only once for a given content length,\n    // and only if onEndReached is not being executed\n    if (\n      onStartReached != null &&\n      this.state.cellsAroundViewport.first === 0 &&\n      isWithinStartThreshold &&\n      this._listMetrics.getContentLength() !== this._sentStartForContentLength\n    ) {\n      this._sentStartForContentLength = this._listMetrics.getContentLength();\n      onStartReached({distanceFromStart});\n    }\n\n    // If the user scrolls away from the start or end and back again,\n    // cause onStartReached or onEndReached to be triggered again\n    if (!isWithinStartThreshold) {\n      this._sentStartForContentLength = 0;\n    }\n    if (!isWithinEndThreshold) {\n      this._sentEndForContentLength = 0;\n    }\n  }\n\n  _onContentSizeChange = (width: number, height: number) => {\n    this._listMetrics.notifyListContentLayout({\n      layout: {width, height},\n      orientation: this._orientation(),\n    });\n\n    this._maybeScrollToInitialScrollIndex(width, height);\n\n    if (this.props.onContentSizeChange) {\n      this.props.onContentSizeChange(width, height);\n    }\n    this._scheduleCellsToRenderUpdate();\n    this._maybeCallOnEdgeReached();\n  };\n\n  /**\n   * Scroll to a specified `initialScrollIndex` prop after the ScrollView\n   * content has been laid out, if it is still valid. Only a single scroll is\n   * triggered throughout the lifetime of the list.\n   */\n  _maybeScrollToInitialScrollIndex(\n    contentWidth: number,\n    contentHeight: number,\n  ) {\n    if (\n      contentWidth > 0 &&\n      contentHeight > 0 &&\n      this.props.initialScrollIndex != null &&\n      this.props.initialScrollIndex > 0 &&\n      !this._hasTriggeredInitialScrollToIndex\n    ) {\n      if (this.props.contentOffset == null) {\n        if (\n          this.props.initialScrollIndex <\n          this.props.getItemCount(this.props.data)\n        ) {\n          this.scrollToIndex({\n            animated: false,\n            index: nullthrows(this.props.initialScrollIndex),\n          });\n        } else {\n          this.scrollToEnd({animated: false});\n        }\n      }\n      this._hasTriggeredInitialScrollToIndex = true;\n    }\n  }\n\n  /* Translates metrics from a scroll event in a parent VirtualizedList into\n   * coordinates relative to the child list.\n   */\n  _convertParentScrollMetrics = (metrics: {\n    visibleLength: number,\n    offset: number,\n    ...\n  }): $FlowFixMe => {\n    // Offset of the top of the nested list relative to the top of its parent's viewport\n    const offset = metrics.offset - this._offsetFromParentVirtualizedList;\n    // Child's visible length is the same as its parent's\n    const visibleLength = metrics.visibleLength;\n    const dOffset = offset - this._scrollMetrics.offset;\n    const contentLength = this._listMetrics.getContentLength();\n\n    return {\n      visibleLength,\n      contentLength,\n      offset,\n      dOffset,\n    };\n  };\n\n  _onScroll = (e: Object) => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScroll(e);\n    });\n    if (this.props.onScroll) {\n      this.props.onScroll(e);\n    }\n    const timestamp = e.timeStamp;\n    let visibleLength = this._selectLength(e.nativeEvent.layoutMeasurement);\n    let contentLength = this._selectLength(e.nativeEvent.contentSize);\n    let offset = this._offsetFromScrollEvent(e);\n    let dOffset = offset - this._scrollMetrics.offset;\n\n    if (this._isNestedWithSameOrientation()) {\n      if (this._listMetrics.getContentLength() === 0) {\n        // Ignore scroll events until onLayout has been called and we\n        // know our offset from our offset from our parent\n        return;\n      }\n      ({visibleLength, contentLength, offset, dOffset} =\n        this._convertParentScrollMetrics({\n          visibleLength,\n          offset,\n        }));\n    }\n\n    const dt = this._scrollMetrics.timestamp\n      ? Math.max(1, timestamp - this._scrollMetrics.timestamp)\n      : 1;\n    const velocity = dOffset / dt;\n\n    if (\n      dt > 500 &&\n      this._scrollMetrics.dt > 500 &&\n      contentLength > 5 * visibleLength &&\n      !this._hasWarned.perf\n    ) {\n      infoLog(\n        'VirtualizedList: You have a large list that is slow to update - make sure your ' +\n          'renderItem function renders components that follow React performance best practices ' +\n          'like PureComponent, shouldComponentUpdate, etc.',\n        {dt, prevDt: this._scrollMetrics.dt, contentLength},\n      );\n      this._hasWarned.perf = true;\n    }\n\n    // For invalid negative values (w/ RTL), set this to 1.\n    const zoomScale = e.nativeEvent.zoomScale < 0 ? 1 : e.nativeEvent.zoomScale;\n    this._scrollMetrics = {\n      dt,\n      dOffset,\n      offset,\n      timestamp,\n      velocity,\n      visibleLength,\n      zoomScale,\n    };\n    if (this.state.pendingScrollUpdateCount > 0) {\n      this.setState(state => ({\n        pendingScrollUpdateCount: state.pendingScrollUpdateCount - 1,\n      }));\n    }\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n    if (!this.props) {\n      return;\n    }\n    this._maybeCallOnEdgeReached();\n    if (velocity !== 0) {\n      this._fillRateHelper.activate();\n    }\n    this._computeBlankness();\n    this._scheduleCellsToRenderUpdate();\n  };\n\n  _offsetFromScrollEvent(e: ScrollEvent): number {\n    const {contentOffset, contentSize, layoutMeasurement} = e.nativeEvent;\n    const {horizontal, rtl} = this._orientation();\n    if (horizontal && rtl) {\n      return (\n        this._selectLength(contentSize) -\n        (this._selectOffset(contentOffset) +\n          this._selectLength(layoutMeasurement))\n      );\n    } else {\n      return this._selectOffset(contentOffset);\n    }\n  }\n\n  _scheduleCellsToRenderUpdate() {\n    // Only trigger high-priority updates if we've actually rendered cells,\n    // and with that size estimate, accurately compute how many cells we should render.\n    // Otherwise, it would just render as many cells as it can (of zero dimension),\n    // each time through attempting to render more (limited by maxToRenderPerBatch),\n    // starving the renderer from actually laying out the objects and computing _averageCellLength.\n    // If this is triggered in an `componentDidUpdate` followed by a hiPri cellToRenderUpdate\n    // We shouldn't do another hipri cellToRenderUpdate\n    if (\n      (this._listMetrics.getAverageCellLength() > 0 ||\n        this.props.getItemLayout != null) &&\n      this._shouldRenderWithPriority() &&\n      !this._hiPriInProgress\n    ) {\n      this._hiPriInProgress = true;\n      // Don't worry about interactions when scrolling quickly; focus on filling content as fast\n      // as possible.\n      this._updateCellsToRenderBatcher.dispose({abort: true});\n      this._updateCellsToRender();\n      return;\n    } else {\n      this._updateCellsToRenderBatcher.schedule();\n    }\n  }\n\n  _shouldRenderWithPriority(): boolean {\n    const {first, last} = this.state.cellsAroundViewport;\n    const {offset, visibleLength, velocity} = this._scrollMetrics;\n    const itemCount = this.props.getItemCount(this.props.data);\n    let hiPri = false;\n    const onStartReachedThreshold = onStartReachedThresholdOrDefault(\n      this.props.onStartReachedThreshold,\n    );\n    const onEndReachedThreshold = onEndReachedThresholdOrDefault(\n      this.props.onEndReachedThreshold,\n    );\n    // Mark as high priority if we're close to the start of the first item\n    // But only if there are items before the first rendered item\n    if (first > 0) {\n      const distTop =\n        offset -\n        this._listMetrics.getCellMetricsApprox(first, this.props).offset;\n      hiPri =\n        distTop < 0 ||\n        (velocity < -2 &&\n          distTop <\n            getScrollingThreshold(onStartReachedThreshold, visibleLength));\n    }\n    // Mark as high priority if we're close to the end of the last item\n    // But only if there are items after the last rendered item\n    if (!hiPri && last >= 0 && last < itemCount - 1) {\n      const distBottom =\n        this._listMetrics.getCellMetricsApprox(last, this.props).offset -\n        (offset + visibleLength);\n      hiPri =\n        distBottom < 0 ||\n        (velocity > 2 &&\n          distBottom <\n            getScrollingThreshold(onEndReachedThreshold, visibleLength));\n    }\n\n    return hiPri;\n  }\n\n  _onScrollBeginDrag = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollBeginDrag(e);\n    });\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.recordInteraction();\n    });\n    this._hasInteracted = true;\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  };\n\n  _onScrollEndDrag = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onScrollEndDrag(e);\n    });\n    const {velocity} = e.nativeEvent;\n    if (velocity) {\n      this._scrollMetrics.velocity = this._selectOffset(velocity);\n    }\n    this._computeBlankness();\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  };\n\n  _onMomentumScrollBegin = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollBegin(e);\n    });\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  };\n\n  _onMomentumScrollEnd = (e: ScrollEvent): void => {\n    this._nestedChildLists.forEach(childList => {\n      childList._onMomentumScrollEnd(e);\n    });\n    this._scrollMetrics.velocity = 0;\n    this._computeBlankness();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  };\n\n  _updateCellsToRender = () => {\n    this._updateViewableItems(this.props, this.state.cellsAroundViewport);\n\n    this.setState((state, props) => {\n      const cellsAroundViewport = this._adjustCellsAroundViewport(\n        props,\n        state.cellsAroundViewport,\n        state.pendingScrollUpdateCount,\n      );\n      const renderMask = VirtualizedList._createRenderMask(\n        props,\n        cellsAroundViewport,\n        this._getNonViewportRenderRegions(props),\n      );\n\n      if (\n        cellsAroundViewport.first === state.cellsAroundViewport.first &&\n        cellsAroundViewport.last === state.cellsAroundViewport.last &&\n        renderMask.equals(state.renderMask)\n      ) {\n        return null;\n      }\n\n      return {cellsAroundViewport, renderMask};\n    });\n  };\n\n  _createViewToken = (\n    index: number,\n    isViewable: boolean,\n    props: CellMetricProps,\n    // $FlowFixMe[missing-local-annot]\n  ) => {\n    const {data, getItem} = props;\n    const item = getItem(data, index);\n    return {\n      index,\n      item,\n      key: VirtualizedList._keyExtractor(item, index, props),\n      isViewable,\n    };\n  };\n\n  __getListMetrics(): ListMetricsAggregator {\n    return this._listMetrics;\n  }\n\n  _getNonViewportRenderRegions = (\n    props: CellMetricProps,\n  ): $ReadOnlyArray<{\n    first: number,\n    last: number,\n  }> => {\n    // Keep a viewport's worth of content around the last focused cell to allow\n    // random navigation around it without any blanking. E.g. tabbing from one\n    // focused item out of viewport to another.\n    if (\n      !(this._lastFocusedCellKey && this._cellRefs[this._lastFocusedCellKey])\n    ) {\n      return [];\n    }\n\n    const lastFocusedCellRenderer = this._cellRefs[this._lastFocusedCellKey];\n    const focusedCellIndex = lastFocusedCellRenderer.props.index;\n    const itemCount = props.getItemCount(props.data);\n\n    // The last cell we rendered may be at a new index. Bail if we don't know\n    // where it is.\n    if (\n      focusedCellIndex >= itemCount ||\n      VirtualizedList._getItemKey(props, focusedCellIndex) !==\n        this._lastFocusedCellKey\n    ) {\n      return [];\n    }\n\n    let first = focusedCellIndex;\n    let heightOfCellsBeforeFocused = 0;\n    for (\n      let i = first - 1;\n      i >= 0 && heightOfCellsBeforeFocused < this._scrollMetrics.visibleLength;\n      i--\n    ) {\n      first--;\n      heightOfCellsBeforeFocused += this._listMetrics.getCellMetricsApprox(\n        i,\n        props,\n      ).length;\n    }\n\n    let last = focusedCellIndex;\n    let heightOfCellsAfterFocused = 0;\n    for (\n      let i = last + 1;\n      i < itemCount &&\n      heightOfCellsAfterFocused < this._scrollMetrics.visibleLength;\n      i++\n    ) {\n      last++;\n      heightOfCellsAfterFocused += this._listMetrics.getCellMetricsApprox(\n        i,\n        props,\n      ).length;\n    }\n\n    return [{first, last}];\n  };\n\n  _updateViewableItems(\n    props: CellMetricProps,\n    cellsAroundViewport: {first: number, last: number},\n  ) {\n    // If we have any pending scroll updates it means that the scroll metrics\n    // are out of date and we should not call any of the visibility callbacks.\n    if (this.state.pendingScrollUpdateCount > 0) {\n      return;\n    }\n    this._viewabilityTuples.forEach(tuple => {\n      tuple.viewabilityHelper.onUpdate(\n        props,\n        this._scrollMetrics.offset,\n        this._scrollMetrics.visibleLength,\n        this._listMetrics,\n        this._createViewToken,\n        tuple.onViewableItemsChanged,\n        cellsAroundViewport,\n      );\n    });\n  }\n}\n\nconst styles = StyleSheet.create({\n  verticallyInverted:\n    Platform.OS === 'android'\n      ? {transform: [{scale: -1}]}\n      : {transform: [{scaleY: -1}]},\n  horizontallyInverted: {\n    transform: [{scaleX: -1}],\n  },\n  debug: {\n    flex: 1,\n  },\n  debugOverlayBase: {\n    position: 'absolute',\n    top: 0,\n    right: 0,\n  },\n  debugOverlay: {\n    bottom: 0,\n    width: 20,\n    borderColor: 'blue',\n    borderWidth: 1,\n  },\n  debugOverlayFrame: {\n    left: 0,\n    backgroundColor: 'orange',\n  },\n  debugOverlayFrameLast: {\n    left: 0,\n    borderColor: 'green',\n    borderWidth: 2,\n  },\n  debugOverlayFrameVis: {\n    left: 0,\n    borderColor: 'red',\n    borderWidth: 2,\n  },\n});\n\nmodule.exports = VirtualizedList;\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"module","externalDependencies":[]}