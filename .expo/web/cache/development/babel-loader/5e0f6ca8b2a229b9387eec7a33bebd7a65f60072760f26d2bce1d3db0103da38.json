{"ast":null,"code":"import NativeEventEmitter from '../EventEmitter/NativeEventEmitter';\nimport logError from '../Utilities/logError';\nimport Platform from '../Utilities/Platform';\nimport NativeAppState from './NativeAppState';\nclass AppState {\n  constructor() {\n    this.currentState = null;\n    this.isAvailable = void 0;\n    this._emitter = void 0;\n    if (NativeAppState == null) {\n      this.isAvailable = false;\n    } else {\n      this.isAvailable = true;\n      const emitter = new NativeEventEmitter(Platform.OS !== 'ios' ? null : NativeAppState);\n      this._emitter = emitter;\n      this.currentState = NativeAppState.getConstants().initialAppState;\n      let eventUpdated = false;\n      emitter.addListener('appStateDidChange', appStateData => {\n        eventUpdated = true;\n        this.currentState = appStateData.app_state;\n      });\n      NativeAppState.getCurrentAppState(appStateData => {\n        if (!eventUpdated && this.currentState !== appStateData.app_state) {\n          this.currentState = appStateData.app_state;\n          emitter.emit('appStateDidChange', appStateData);\n        }\n      }, logError);\n    }\n  }\n  addEventListener(type, handler) {\n    const emitter = this._emitter;\n    if (emitter == null) {\n      throw new Error('Cannot use AppState when `isAvailable` is false.');\n    }\n    switch (type) {\n      case 'change':\n        const changeHandler = handler;\n        return emitter.addListener('appStateDidChange', appStateData => {\n          changeHandler(appStateData.app_state);\n        });\n      case 'memoryWarning':\n        const memoryWarningHandler = handler;\n        return emitter.addListener('memoryWarning', memoryWarningHandler);\n      case 'blur':\n      case 'focus':\n        const focusOrBlurHandler = handler;\n        return emitter.addListener('appStateFocusChange', hasFocus => {\n          if (type === 'blur' && !hasFocus) {\n            focusOrBlurHandler();\n          }\n          if (type === 'focus' && hasFocus) {\n            focusOrBlurHandler();\n          }\n        });\n    }\n    throw new Error('Trying to subscribe to unknown event: ' + type);\n  }\n}\nmodule.exports = new AppState();","map":{"version":3,"names":["NativeEventEmitter","logError","Platform","NativeAppState","AppState","constructor","currentState","isAvailable","_emitter","emitter","OS","getConstants","initialAppState","eventUpdated","addListener","appStateData","app_state","getCurrentAppState","emit","addEventListener","type","handler","Error","changeHandler","memoryWarningHandler","focusOrBlurHandler","hasFocus","module","exports"],"sources":["F:/MiniProject/node_modules/react-native/Libraries/AppState/AppState.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport NativeEventEmitter from '../EventEmitter/NativeEventEmitter';\nimport logError from '../Utilities/logError';\nimport Platform from '../Utilities/Platform';\nimport {type EventSubscription} from '../vendor/emitter/EventEmitter';\nimport NativeAppState from './NativeAppState';\n\nexport type AppStateValues = 'inactive' | 'background' | 'active';\n\ntype AppStateEventDefinitions = {\n  change: [AppStateValues],\n  memoryWarning: [],\n  blur: [],\n  focus: [],\n};\n\ntype NativeAppStateEventDefinitions = {\n  appStateDidChange: [{app_state: AppStateValues}],\n  appStateFocusChange: [boolean],\n  memoryWarning: [],\n};\n\n/**\n * `AppState` can tell you if the app is in the foreground or background,\n * and notify you when the state changes.\n *\n * See https://reactnative.dev/docs/appstate\n */\nclass AppState {\n  currentState: ?string = null;\n  isAvailable: boolean;\n\n  _emitter: ?NativeEventEmitter<NativeAppStateEventDefinitions>;\n\n  constructor() {\n    if (NativeAppState == null) {\n      this.isAvailable = false;\n    } else {\n      this.isAvailable = true;\n\n      const emitter: NativeEventEmitter<NativeAppStateEventDefinitions> =\n        new NativeEventEmitter(\n          // T88715063: NativeEventEmitter only used this parameter on iOS. Now it uses it on all platforms, so this code was modified automatically to preserve its behavior\n          // If you want to use the native module on other platforms, please remove this condition and test its behavior\n          Platform.OS !== 'ios' ? null : NativeAppState,\n        );\n      this._emitter = emitter;\n\n      this.currentState = NativeAppState.getConstants().initialAppState;\n\n      let eventUpdated = false;\n\n      // TODO: this is a terrible solution - in order to ensure `currentState`\n      // prop is up to date, we have to register an observer that updates it\n      // whenever the state changes, even if nobody cares. We should just\n      // deprecate the `currentState` property and get rid of this.\n      emitter.addListener('appStateDidChange', appStateData => {\n        eventUpdated = true;\n        this.currentState = appStateData.app_state;\n      });\n\n      // TODO: see above - this request just populates the value of `currentState`\n      // when the module is first initialized. Would be better to get rid of the\n      // prop and expose `getCurrentAppState` method directly.\n      // $FlowExpectedError[incompatible-call]\n      NativeAppState.getCurrentAppState(appStateData => {\n        // It's possible that the state will have changed here & listeners need to be notified\n        if (!eventUpdated && this.currentState !== appStateData.app_state) {\n          this.currentState = appStateData.app_state;\n          // $FlowFixMe[incompatible-call]\n          emitter.emit('appStateDidChange', appStateData);\n        }\n      }, logError);\n    }\n  }\n\n  /**\n   * Add a handler to AppState changes by listening to the `change` event type\n   * and providing the handler.\n   *\n   * See https://reactnative.dev/docs/appstate#addeventlistener\n   */\n  addEventListener<K: $Keys<AppStateEventDefinitions>>(\n    type: K,\n    handler: (...$ElementType<AppStateEventDefinitions, K>) => void,\n  ): EventSubscription {\n    const emitter = this._emitter;\n    if (emitter == null) {\n      throw new Error('Cannot use AppState when `isAvailable` is false.');\n    }\n    switch (type) {\n      case 'change':\n        // $FlowIssue[invalid-tuple-arity] Flow cannot refine handler based on the event type\n        const changeHandler: AppStateValues => void = handler;\n        return emitter.addListener('appStateDidChange', appStateData => {\n          changeHandler(appStateData.app_state);\n        });\n      case 'memoryWarning':\n        // $FlowIssue[invalid-tuple-arity] Flow cannot refine handler based on the event type\n        const memoryWarningHandler: () => void = handler;\n        return emitter.addListener('memoryWarning', memoryWarningHandler);\n      case 'blur':\n      case 'focus':\n        // $FlowIssue[invalid-tuple-arity] Flow cannot refine handler based on the event type\n        const focusOrBlurHandler: () => void = handler;\n        return emitter.addListener('appStateFocusChange', hasFocus => {\n          if (type === 'blur' && !hasFocus) {\n            focusOrBlurHandler();\n          }\n          if (type === 'focus' && hasFocus) {\n            focusOrBlurHandler();\n          }\n        });\n    }\n    throw new Error('Trying to subscribe to unknown event: ' + type);\n  }\n}\n\nmodule.exports = (new AppState(): AppState);\n"],"mappings":"AAUA,OAAOA,kBAAkB,MAAM,oCAAoC;AACnE,OAAOC,QAAQ,MAAM,uBAAuB;AAC5C,OAAOC,QAAQ,MAAM,uBAAuB;AAE5C,OAAOC,cAAc,MAAM,kBAAkB;AAuB7C,MAAMC,QAAQ,CAAC;EAMbC,WAAWA,CAAA,EAAG;IAAA,KALdC,YAAY,GAAY,IAAI;IAAA,KAC5BC,WAAW;IAAA,KAEXC,QAAQ;IAGN,IAAIL,cAAc,IAAI,IAAI,EAAE;MAC1B,IAAI,CAACI,WAAW,GAAG,KAAK;IAC1B,CAAC,MAAM;MACL,IAAI,CAACA,WAAW,GAAG,IAAI;MAEvB,MAAME,OAA2D,GAC/D,IAAIT,kBAAkB,CAGpBE,QAAQ,CAACQ,EAAE,KAAK,KAAK,GAAG,IAAI,GAAGP,cACjC,CAAC;MACH,IAAI,CAACK,QAAQ,GAAGC,OAAO;MAEvB,IAAI,CAACH,YAAY,GAAGH,cAAc,CAACQ,YAAY,CAAC,CAAC,CAACC,eAAe;MAEjE,IAAIC,YAAY,GAAG,KAAK;MAMxBJ,OAAO,CAACK,WAAW,CAAC,mBAAmB,EAAEC,YAAY,IAAI;QACvDF,YAAY,GAAG,IAAI;QACnB,IAAI,CAACP,YAAY,GAAGS,YAAY,CAACC,SAAS;MAC5C,CAAC,CAAC;MAMFb,cAAc,CAACc,kBAAkB,CAACF,YAAY,IAAI;QAEhD,IAAI,CAACF,YAAY,IAAI,IAAI,CAACP,YAAY,KAAKS,YAAY,CAACC,SAAS,EAAE;UACjE,IAAI,CAACV,YAAY,GAAGS,YAAY,CAACC,SAAS;UAE1CP,OAAO,CAACS,IAAI,CAAC,mBAAmB,EAAEH,YAAY,CAAC;QACjD;MACF,CAAC,EAAEd,QAAQ,CAAC;IACd;EACF;EAQAkB,gBAAgBA,CACdC,IAAO,EACPC,OAA+D,EAC5C;IACnB,MAAMZ,OAAO,GAAG,IAAI,CAACD,QAAQ;IAC7B,IAAIC,OAAO,IAAI,IAAI,EAAE;MACnB,MAAM,IAAIa,KAAK,CAAC,kDAAkD,CAAC;IACrE;IACA,QAAQF,IAAI;MACV,KAAK,QAAQ;QAEX,MAAMG,aAAqC,GAAGF,OAAO;QACrD,OAAOZ,OAAO,CAACK,WAAW,CAAC,mBAAmB,EAAEC,YAAY,IAAI;UAC9DQ,aAAa,CAACR,YAAY,CAACC,SAAS,CAAC;QACvC,CAAC,CAAC;MACJ,KAAK,eAAe;QAElB,MAAMQ,oBAAgC,GAAGH,OAAO;QAChD,OAAOZ,OAAO,CAACK,WAAW,CAAC,eAAe,EAAEU,oBAAoB,CAAC;MACnE,KAAK,MAAM;MACX,KAAK,OAAO;QAEV,MAAMC,kBAA8B,GAAGJ,OAAO;QAC9C,OAAOZ,OAAO,CAACK,WAAW,CAAC,qBAAqB,EAAEY,QAAQ,IAAI;UAC5D,IAAIN,IAAI,KAAK,MAAM,IAAI,CAACM,QAAQ,EAAE;YAChCD,kBAAkB,CAAC,CAAC;UACtB;UACA,IAAIL,IAAI,KAAK,OAAO,IAAIM,QAAQ,EAAE;YAChCD,kBAAkB,CAAC,CAAC;UACtB;QACF,CAAC,CAAC;IACN;IACA,MAAM,IAAIH,KAAK,CAAC,wCAAwC,GAAGF,IAAI,CAAC;EAClE;AACF;AAEAO,MAAM,CAACC,OAAO,GAAI,IAAIxB,QAAQ,CAAC,CAAY","ignoreList":[]},"metadata":{"hasCjsExports":true},"sourceType":"module","externalDependencies":[]}