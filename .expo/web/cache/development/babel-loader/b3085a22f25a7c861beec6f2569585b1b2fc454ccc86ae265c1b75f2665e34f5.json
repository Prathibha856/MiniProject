{"ast":null,"code":"import { keyExtractor as defaultKeyExtractor } from './VirtualizeUtils';\nimport invariant from 'invariant';\nexport default class ListMetricsAggregator {\n  constructor() {\n    this._averageCellLength = 0;\n    this._cellMetrics = new Map();\n    this._contentLength = void 0;\n    this._highestMeasuredCellIndex = 0;\n    this._measuredCellsLength = 0;\n    this._measuredCellsCount = 0;\n    this._orientation = {\n      horizontal: false,\n      rtl: false\n    };\n  }\n  notifyCellLayout({\n    cellIndex,\n    cellKey,\n    orientation,\n    layout\n  }) {\n    this._invalidateIfOrientationChanged(orientation);\n    const next = {\n      index: cellIndex,\n      length: this._selectLength(layout),\n      isMounted: true,\n      offset: this.flowRelativeOffset(layout)\n    };\n    const curr = this._cellMetrics.get(cellKey);\n    if (!curr || next.offset !== curr.offset || next.length !== curr.length) {\n      if (curr) {\n        const dLength = next.length - curr.length;\n        this._measuredCellsLength += dLength;\n      } else {\n        this._measuredCellsLength += next.length;\n        this._measuredCellsCount += 1;\n      }\n      this._averageCellLength = this._measuredCellsLength / this._measuredCellsCount;\n      this._cellMetrics.set(cellKey, next);\n      this._highestMeasuredCellIndex = Math.max(this._highestMeasuredCellIndex, cellIndex);\n      return true;\n    } else {\n      curr.isMounted = true;\n      return false;\n    }\n  }\n  notifyCellUnmounted(cellKey) {\n    const curr = this._cellMetrics.get(cellKey);\n    if (curr) {\n      curr.isMounted = false;\n    }\n  }\n  notifyListContentLayout({\n    orientation,\n    layout\n  }) {\n    this._invalidateIfOrientationChanged(orientation);\n    this._contentLength = this._selectLength(layout);\n  }\n  getAverageCellLength() {\n    return this._averageCellLength;\n  }\n  getHighestMeasuredCellIndex() {\n    return this._highestMeasuredCellIndex;\n  }\n  getCellMetricsApprox(index, props) {\n    const frame = this.getCellMetrics(index, props);\n    if (frame && frame.index === index) {\n      return frame;\n    } else {\n      const {\n        data,\n        getItemCount\n      } = props;\n      invariant(index >= 0 && index < getItemCount(data), 'Tried to get frame for out of range index ' + index);\n      return {\n        length: this._averageCellLength,\n        offset: this._averageCellLength * index,\n        index,\n        isMounted: false\n      };\n    }\n  }\n  getCellMetrics(index, props) {\n    const {\n      data,\n      getItem,\n      getItemCount,\n      getItemLayout\n    } = props;\n    invariant(index >= 0 && index < getItemCount(data), 'Tried to get metrics for out of range cell index ' + index);\n    const keyExtractor = props.keyExtractor ?? defaultKeyExtractor;\n    const frame = this._cellMetrics.get(keyExtractor(getItem(data, index), index));\n    if (frame && frame.index === index) {\n      return frame;\n    }\n    if (getItemLayout) {\n      const {\n        length,\n        offset\n      } = getItemLayout(data, index);\n      return {\n        index,\n        length,\n        offset,\n        isMounted: true\n      };\n    }\n    return null;\n  }\n  getCellOffsetApprox(index, props) {\n    if (Number.isInteger(index)) {\n      return this.getCellMetricsApprox(index, props).offset;\n    } else {\n      const frameMetrics = this.getCellMetricsApprox(Math.floor(index), props);\n      const remainder = index - Math.floor(index);\n      return frameMetrics.offset + remainder * frameMetrics.length;\n    }\n  }\n  getContentLength() {\n    return this._contentLength ?? 0;\n  }\n  hasContentLength() {\n    return this._contentLength != null;\n  }\n  flowRelativeOffset(layout, referenceContentLength) {\n    const {\n      horizontal,\n      rtl\n    } = this._orientation;\n    if (horizontal && rtl) {\n      const contentLength = referenceContentLength ?? this._contentLength;\n      invariant(contentLength != null, 'ListMetricsAggregator must be notified of list content layout before resolving offsets');\n      return contentLength - (this._selectOffset(layout) + this._selectLength(layout));\n    } else {\n      return this._selectOffset(layout);\n    }\n  }\n  cartesianOffset(flowRelativeOffset) {\n    const {\n      horizontal,\n      rtl\n    } = this._orientation;\n    if (horizontal && rtl) {\n      invariant(this._contentLength != null, 'ListMetricsAggregator must be notified of list content layout before resolving offsets');\n      return this._contentLength - flowRelativeOffset;\n    } else {\n      return flowRelativeOffset;\n    }\n  }\n  _invalidateIfOrientationChanged(orientation) {\n    if (orientation.rtl !== this._orientation.rtl) {\n      this._cellMetrics.clear();\n    }\n    if (orientation.horizontal !== this._orientation.horizontal) {\n      this._averageCellLength = 0;\n      this._highestMeasuredCellIndex = 0;\n      this._measuredCellsLength = 0;\n      this._measuredCellsCount = 0;\n    }\n    this._orientation = orientation;\n  }\n  _selectLength({\n    width,\n    height\n  }) {\n    return this._orientation.horizontal ? width : height;\n  }\n  _selectOffset({\n    x,\n    y\n  }) {\n    return this._orientation.horizontal ? x : y;\n  }\n}","map":{"version":3,"names":["keyExtractor","defaultKeyExtractor","invariant","ListMetricsAggregator","constructor","_averageCellLength","_cellMetrics","Map","_contentLength","_highestMeasuredCellIndex","_measuredCellsLength","_measuredCellsCount","_orientation","horizontal","rtl","notifyCellLayout","cellIndex","cellKey","orientation","layout","_invalidateIfOrientationChanged","next","index","length","_selectLength","isMounted","offset","flowRelativeOffset","curr","get","dLength","set","Math","max","notifyCellUnmounted","notifyListContentLayout","getAverageCellLength","getHighestMeasuredCellIndex","getCellMetricsApprox","props","frame","getCellMetrics","data","getItemCount","getItem","getItemLayout","getCellOffsetApprox","Number","isInteger","frameMetrics","floor","remainder","getContentLength","hasContentLength","referenceContentLength","contentLength","_selectOffset","cartesianOffset","clear","width","height","x","y"],"sources":["F:/MiniProject/node_modules/@react-native/virtualized-lists/Lists/ListMetricsAggregator.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport type {Props as VirtualizedListProps} from './VirtualizedListProps';\nimport type {Layout} from 'react-native/Libraries/Types/CoreEventTypes';\n\nimport {keyExtractor as defaultKeyExtractor} from './VirtualizeUtils';\nimport invariant from 'invariant';\n\nexport type CellMetrics = {\n  /**\n   * Index of the item in the list\n   */\n  index: number,\n  /**\n   * Length of the cell along the scrolling axis\n   */\n  length: number,\n  /**\n   * Distance between this cell and the start of the list along the scrolling\n   * axis\n   */\n  offset: number,\n  /**\n   * Whether the cell is last known to be mounted\n   */\n  isMounted: boolean,\n};\n\n// TODO: `inverted` can be incorporated here if it is moved to an order\n// based implementation instead of transform.\nexport type ListOrientation = {\n  horizontal: boolean,\n  rtl: boolean,\n};\n\n/**\n * Subset of VirtualizedList props needed to calculate cell metrics\n */\nexport type CellMetricProps = {\n  data: VirtualizedListProps['data'],\n  getItemCount: VirtualizedListProps['getItemCount'],\n  getItem: VirtualizedListProps['getItem'],\n  getItemLayout?: VirtualizedListProps['getItemLayout'],\n  keyExtractor?: VirtualizedListProps['keyExtractor'],\n  ...\n};\n\n/**\n * Provides an interface to query information about the metrics of a list and its cells.\n */\nexport default class ListMetricsAggregator {\n  _averageCellLength = 0;\n  _cellMetrics: Map<string, CellMetrics> = new Map();\n  _contentLength: ?number;\n  _highestMeasuredCellIndex = 0;\n  _measuredCellsLength = 0;\n  _measuredCellsCount = 0;\n  _orientation: ListOrientation = {\n    horizontal: false,\n    rtl: false,\n  };\n\n  /**\n   * Notify the ListMetricsAggregator that a cell has been laid out.\n   *\n   * @returns whether the cell layout has changed since last notification\n   */\n  notifyCellLayout({\n    cellIndex,\n    cellKey,\n    orientation,\n    layout,\n  }: {\n    cellIndex: number,\n    cellKey: string,\n    orientation: ListOrientation,\n    layout: Layout,\n  }): boolean {\n    this._invalidateIfOrientationChanged(orientation);\n\n    const next: CellMetrics = {\n      index: cellIndex,\n      length: this._selectLength(layout),\n      isMounted: true,\n      offset: this.flowRelativeOffset(layout),\n    };\n    const curr = this._cellMetrics.get(cellKey);\n\n    if (!curr || next.offset !== curr.offset || next.length !== curr.length) {\n      if (curr) {\n        const dLength = next.length - curr.length;\n        this._measuredCellsLength += dLength;\n      } else {\n        this._measuredCellsLength += next.length;\n        this._measuredCellsCount += 1;\n      }\n\n      this._averageCellLength =\n        this._measuredCellsLength / this._measuredCellsCount;\n      this._cellMetrics.set(cellKey, next);\n      this._highestMeasuredCellIndex = Math.max(\n        this._highestMeasuredCellIndex,\n        cellIndex,\n      );\n      return true;\n    } else {\n      curr.isMounted = true;\n      return false;\n    }\n  }\n\n  /**\n   * Notify ListMetricsAggregator that a cell has been unmounted.\n   */\n  notifyCellUnmounted(cellKey: string): void {\n    const curr = this._cellMetrics.get(cellKey);\n    if (curr) {\n      curr.isMounted = false;\n    }\n  }\n\n  /**\n   * Notify ListMetricsAggregator that the lists content container has been laid out.\n   */\n  notifyListContentLayout({\n    orientation,\n    layout,\n  }: {\n    orientation: ListOrientation,\n    layout: $ReadOnly<{width: number, height: number}>,\n  }): void {\n    this._invalidateIfOrientationChanged(orientation);\n    this._contentLength = this._selectLength(layout);\n  }\n\n  /**\n   * Return the average length of the cells which have been measured\n   */\n  getAverageCellLength(): number {\n    return this._averageCellLength;\n  }\n\n  /**\n   * Return the highest measured cell index (or 0 if nothing has been measured\n   * yet)\n   */\n  getHighestMeasuredCellIndex(): number {\n    return this._highestMeasuredCellIndex;\n  }\n\n  /**\n   * Returns the exact metrics of a cell if it has already been laid out,\n   * otherwise an estimate based on the average length of previously measured\n   * cells\n   */\n  getCellMetricsApprox(index: number, props: CellMetricProps): CellMetrics {\n    const frame = this.getCellMetrics(index, props);\n    if (frame && frame.index === index) {\n      // check for invalid frames due to row re-ordering\n      return frame;\n    } else {\n      const {data, getItemCount} = props;\n      invariant(\n        index >= 0 && index < getItemCount(data),\n        'Tried to get frame for out of range index ' + index,\n      );\n      return {\n        length: this._averageCellLength,\n        offset: this._averageCellLength * index,\n        index,\n        isMounted: false,\n      };\n    }\n  }\n\n  /**\n   * Returns the exact metrics of a cell if it has already been laid out\n   */\n  getCellMetrics(index: number, props: CellMetricProps): ?CellMetrics {\n    const {data, getItem, getItemCount, getItemLayout} = props;\n    invariant(\n      index >= 0 && index < getItemCount(data),\n      'Tried to get metrics for out of range cell index ' + index,\n    );\n    const keyExtractor = props.keyExtractor ?? defaultKeyExtractor;\n    const frame = this._cellMetrics.get(\n      keyExtractor(getItem(data, index), index),\n    );\n    if (frame && frame.index === index) {\n      return frame;\n    }\n\n    if (getItemLayout) {\n      const {length, offset} = getItemLayout(data, index);\n      // TODO: `isMounted` is used for both \"is exact layout\" and \"has been\n      // unmounted\". Should be refactored.\n      return {index, length, offset, isMounted: true};\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets an approximate offset to an item at a given index. Supports\n   * fractional indices.\n   */\n  getCellOffsetApprox(index: number, props: CellMetricProps): number {\n    if (Number.isInteger(index)) {\n      return this.getCellMetricsApprox(index, props).offset;\n    } else {\n      const frameMetrics = this.getCellMetricsApprox(Math.floor(index), props);\n      const remainder = index - Math.floor(index);\n      return frameMetrics.offset + remainder * frameMetrics.length;\n    }\n  }\n\n  /**\n   * Returns the length of all ScrollView content along the scrolling axis.\n   */\n  getContentLength(): number {\n    return this._contentLength ?? 0;\n  }\n\n  /**\n   * Whether a content length has been observed\n   */\n  hasContentLength(): boolean {\n    return this._contentLength != null;\n  }\n\n  /**\n   * Finds the flow-relative offset (e.g. starting from the left in LTR, but\n   * right in RTL) from a layout box.\n   */\n  flowRelativeOffset(layout: Layout, referenceContentLength?: ?number): number {\n    const {horizontal, rtl} = this._orientation;\n\n    if (horizontal && rtl) {\n      const contentLength = referenceContentLength ?? this._contentLength;\n      invariant(\n        contentLength != null,\n        'ListMetricsAggregator must be notified of list content layout before resolving offsets',\n      );\n      return (\n        contentLength -\n        (this._selectOffset(layout) + this._selectLength(layout))\n      );\n    } else {\n      return this._selectOffset(layout);\n    }\n  }\n\n  /**\n   * Converts a flow-relative offset to a cartesian offset\n   */\n  cartesianOffset(flowRelativeOffset: number): number {\n    const {horizontal, rtl} = this._orientation;\n\n    if (horizontal && rtl) {\n      invariant(\n        this._contentLength != null,\n        'ListMetricsAggregator must be notified of list content layout before resolving offsets',\n      );\n      return this._contentLength - flowRelativeOffset;\n    } else {\n      return flowRelativeOffset;\n    }\n  }\n\n  _invalidateIfOrientationChanged(orientation: ListOrientation): void {\n    if (orientation.rtl !== this._orientation.rtl) {\n      this._cellMetrics.clear();\n    }\n\n    if (orientation.horizontal !== this._orientation.horizontal) {\n      this._averageCellLength = 0;\n      this._highestMeasuredCellIndex = 0;\n      this._measuredCellsLength = 0;\n      this._measuredCellsCount = 0;\n    }\n\n    this._orientation = orientation;\n  }\n\n  _selectLength({\n    width,\n    height,\n  }: $ReadOnly<{width: number, height: number, ...}>): number {\n    return this._orientation.horizontal ? width : height;\n  }\n\n  _selectOffset({x, y}: $ReadOnly<{x: number, y: number, ...}>): number {\n    return this._orientation.horizontal ? x : y;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}