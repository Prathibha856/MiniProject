{"ast":null,"code":"'use strict';\n\nimport * as ReactNativeFeatureFlags from '../../../src/private/featureflags/ReactNativeFeatureFlags';\nimport NativeAnimatedHelper from '../../../src/private/animated/NativeAnimatedHelper';\nimport AnimatedProps from '../nodes/AnimatedProps';\nlet startNativeAnimationNextId = 1;\nexport default class Animation {\n  constructor() {\n    this.__active = void 0;\n    this.__isInteraction = void 0;\n    this.__onEnd = void 0;\n    this.__iterations = void 0;\n    this.__isLooping = void 0;\n    this._nativeId = void 0;\n  }\n  start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {}\n  stop() {\n    if (this._nativeId) {\n      NativeAnimatedHelper.API.stopAnimation(this._nativeId);\n    }\n  }\n  __getNativeAnimationConfig() {\n    throw new Error('This animation type cannot be offloaded to native');\n  }\n  __debouncedOnEnd(result) {\n    const onEnd = this.__onEnd;\n    this.__onEnd = null;\n    onEnd && onEnd(result);\n  }\n  __findAnimatedPropsNodes(node) {\n    const result = [];\n    if (node instanceof AnimatedProps) {\n      result.push(node);\n      return result;\n    }\n    for (const child of node.__getChildren()) {\n      result.push(...this.__findAnimatedPropsNodes(child));\n    }\n    return result;\n  }\n  __startNativeAnimation(animatedValue) {\n    const startNativeAnimationWaitId = `${startNativeAnimationNextId}:startAnimation`;\n    startNativeAnimationNextId += 1;\n    NativeAnimatedHelper.API.setWaitingForIdentifier(startNativeAnimationWaitId);\n    try {\n      const config = this.__getNativeAnimationConfig();\n      animatedValue.__makeNative(config.platformConfig);\n      this._nativeId = NativeAnimatedHelper.generateNewAnimationId();\n      NativeAnimatedHelper.API.startAnimatingNode(this._nativeId, animatedValue.__getNativeTag(), config, result => {\n        this.__debouncedOnEnd(result);\n        const {\n          value\n        } = result;\n        if (value != null) {\n          animatedValue.__onAnimatedValueUpdateReceived(value);\n          if (ReactNativeFeatureFlags.shouldSkipStateUpdatesForLoopingAnimations() && this.__isLooping) {\n            return;\n          }\n          this.__findAnimatedPropsNodes(animatedValue).forEach(node => node.update());\n        }\n      });\n    } catch (e) {\n      throw e;\n    } finally {\n      NativeAnimatedHelper.API.unsetWaitingForIdentifier(startNativeAnimationWaitId);\n    }\n  }\n}","map":{"version":3,"names":["ReactNativeFeatureFlags","NativeAnimatedHelper","AnimatedProps","startNativeAnimationNextId","Animation","constructor","__active","__isInteraction","__onEnd","__iterations","__isLooping","_nativeId","start","fromValue","onUpdate","onEnd","previousAnimation","animatedValue","stop","API","stopAnimation","__getNativeAnimationConfig","Error","__debouncedOnEnd","result","__findAnimatedPropsNodes","node","push","child","__getChildren","__startNativeAnimation","startNativeAnimationWaitId","setWaitingForIdentifier","config","__makeNative","platformConfig","generateNewAnimationId","startAnimatingNode","__getNativeTag","value","__onAnimatedValueUpdateReceived","shouldSkipStateUpdatesForLoopingAnimations","forEach","update","e","unsetWaitingForIdentifier"],"sources":["F:/MiniProject/node_modules/react-native/Libraries/Animated/animations/Animation.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport type {PlatformConfig} from '../AnimatedPlatformConfig';\nimport type AnimatedNode from '../nodes/AnimatedNode';\nimport type AnimatedValue from '../nodes/AnimatedValue';\n\nimport * as ReactNativeFeatureFlags from '../../../src/private/featureflags/ReactNativeFeatureFlags';\nimport NativeAnimatedHelper from '../../../src/private/animated/NativeAnimatedHelper';\nimport AnimatedProps from '../nodes/AnimatedProps';\n\nexport type EndResult = {finished: boolean, value?: number, ...};\nexport type EndCallback = (result: EndResult) => void;\n\nexport type AnimationConfig = {\n  isInteraction?: boolean,\n  useNativeDriver: boolean,\n  platformConfig?: PlatformConfig,\n  onComplete?: ?EndCallback,\n  iterations?: number,\n  isLooping?: boolean,\n};\n\nlet startNativeAnimationNextId = 1;\n\n// Important note: start() and stop() will only be called at most once.\n// Once an animation has been stopped or finished its course, it will\n// not be reused.\nexport default class Animation {\n  __active: boolean;\n  __isInteraction: boolean;\n  __onEnd: ?EndCallback;\n  __iterations: number;\n  __isLooping: ?boolean;\n\n  _nativeId: number;\n\n  start(\n    fromValue: number,\n    onUpdate: (value: number) => void,\n    onEnd: ?EndCallback,\n    previousAnimation: ?Animation,\n    animatedValue: AnimatedValue,\n  ): void {}\n\n  stop(): void {\n    if (this._nativeId) {\n      NativeAnimatedHelper.API.stopAnimation(this._nativeId);\n    }\n  }\n\n  __getNativeAnimationConfig(): any {\n    // Subclasses that have corresponding animation implementation done in native\n    // should override this method\n    throw new Error('This animation type cannot be offloaded to native');\n  }\n\n  // Helper function for subclasses to make sure onEnd is only called once.\n  __debouncedOnEnd(result: EndResult): void {\n    const onEnd = this.__onEnd;\n    this.__onEnd = null;\n    onEnd && onEnd(result);\n  }\n\n  __findAnimatedPropsNodes(node: AnimatedNode): Array<AnimatedProps> {\n    const result = [];\n\n    if (node instanceof AnimatedProps) {\n      result.push(node);\n      return result;\n    }\n\n    for (const child of node.__getChildren()) {\n      result.push(...this.__findAnimatedPropsNodes(child));\n    }\n\n    return result;\n  }\n\n  __startNativeAnimation(animatedValue: AnimatedValue): void {\n    const startNativeAnimationWaitId = `${startNativeAnimationNextId}:startAnimation`;\n    startNativeAnimationNextId += 1;\n    NativeAnimatedHelper.API.setWaitingForIdentifier(\n      startNativeAnimationWaitId,\n    );\n    try {\n      const config = this.__getNativeAnimationConfig();\n      animatedValue.__makeNative(config.platformConfig);\n      this._nativeId = NativeAnimatedHelper.generateNewAnimationId();\n      NativeAnimatedHelper.API.startAnimatingNode(\n        this._nativeId,\n        animatedValue.__getNativeTag(),\n        config,\n        result => {\n          this.__debouncedOnEnd(result);\n\n          // When using natively driven animations, once the animation completes,\n          // we need to ensure that the JS side nodes are synced with the updated\n          // values.\n          const {value} = result;\n          if (value != null) {\n            animatedValue.__onAnimatedValueUpdateReceived(value);\n\n            if (\n              ReactNativeFeatureFlags.shouldSkipStateUpdatesForLoopingAnimations() &&\n              this.__isLooping\n            ) {\n              return;\n            }\n\n            // Once the JS side node is synced with the updated values, trigger an\n            // update on the AnimatedProps nodes to call any registered callbacks.\n            this.__findAnimatedPropsNodes(animatedValue).forEach(node =>\n              node.update(),\n            );\n          }\n        },\n      );\n    } catch (e) {\n      throw e;\n    } finally {\n      NativeAnimatedHelper.API.unsetWaitingForIdentifier(\n        startNativeAnimationWaitId,\n      );\n    }\n  }\n}\n"],"mappings":"AAUA,YAAY;;AAMZ,OAAO,KAAKA,uBAAuB,MAAM,2DAA2D;AACpG,OAAOC,oBAAoB,MAAM,oDAAoD;AACrF,OAAOC,aAAa,MAAM,wBAAwB;AAclD,IAAIC,0BAA0B,GAAG,CAAC;AAKlC,eAAe,MAAMC,SAAS,CAAC;EAAAC,YAAA;IAAA,KAC7BC,QAAQ;IAAA,KACRC,eAAe;IAAA,KACfC,OAAO;IAAA,KACPC,YAAY;IAAA,KACZC,WAAW;IAAA,KAEXC,SAAS;EAAA;EAETC,KAAKA,CACHC,SAAiB,EACjBC,QAAiC,EACjCC,KAAmB,EACnBC,iBAA6B,EAC7BC,aAA4B,EACtB,CAAC;EAETC,IAAIA,CAAA,EAAS;IACX,IAAI,IAAI,CAACP,SAAS,EAAE;MAClBV,oBAAoB,CAACkB,GAAG,CAACC,aAAa,CAAC,IAAI,CAACT,SAAS,CAAC;IACxD;EACF;EAEAU,0BAA0BA,CAAA,EAAQ;IAGhC,MAAM,IAAIC,KAAK,CAAC,mDAAmD,CAAC;EACtE;EAGAC,gBAAgBA,CAACC,MAAiB,EAAQ;IACxC,MAAMT,KAAK,GAAG,IAAI,CAACP,OAAO;IAC1B,IAAI,CAACA,OAAO,GAAG,IAAI;IACnBO,KAAK,IAAIA,KAAK,CAACS,MAAM,CAAC;EACxB;EAEAC,wBAAwBA,CAACC,IAAkB,EAAwB;IACjE,MAAMF,MAAM,GAAG,EAAE;IAEjB,IAAIE,IAAI,YAAYxB,aAAa,EAAE;MACjCsB,MAAM,CAACG,IAAI,CAACD,IAAI,CAAC;MACjB,OAAOF,MAAM;IACf;IAEA,KAAK,MAAMI,KAAK,IAAIF,IAAI,CAACG,aAAa,CAAC,CAAC,EAAE;MACxCL,MAAM,CAACG,IAAI,CAAC,GAAG,IAAI,CAACF,wBAAwB,CAACG,KAAK,CAAC,CAAC;IACtD;IAEA,OAAOJ,MAAM;EACf;EAEAM,sBAAsBA,CAACb,aAA4B,EAAQ;IACzD,MAAMc,0BAA0B,GAAG,GAAG5B,0BAA0B,iBAAiB;IACjFA,0BAA0B,IAAI,CAAC;IAC/BF,oBAAoB,CAACkB,GAAG,CAACa,uBAAuB,CAC9CD,0BACF,CAAC;IACD,IAAI;MACF,MAAME,MAAM,GAAG,IAAI,CAACZ,0BAA0B,CAAC,CAAC;MAChDJ,aAAa,CAACiB,YAAY,CAACD,MAAM,CAACE,cAAc,CAAC;MACjD,IAAI,CAACxB,SAAS,GAAGV,oBAAoB,CAACmC,sBAAsB,CAAC,CAAC;MAC9DnC,oBAAoB,CAACkB,GAAG,CAACkB,kBAAkB,CACzC,IAAI,CAAC1B,SAAS,EACdM,aAAa,CAACqB,cAAc,CAAC,CAAC,EAC9BL,MAAM,EACNT,MAAM,IAAI;QACR,IAAI,CAACD,gBAAgB,CAACC,MAAM,CAAC;QAK7B,MAAM;UAACe;QAAK,CAAC,GAAGf,MAAM;QACtB,IAAIe,KAAK,IAAI,IAAI,EAAE;UACjBtB,aAAa,CAACuB,+BAA+B,CAACD,KAAK,CAAC;UAEpD,IACEvC,uBAAuB,CAACyC,0CAA0C,CAAC,CAAC,IACpE,IAAI,CAAC/B,WAAW,EAChB;YACA;UACF;UAIA,IAAI,CAACe,wBAAwB,CAACR,aAAa,CAAC,CAACyB,OAAO,CAAChB,IAAI,IACvDA,IAAI,CAACiB,MAAM,CAAC,CACd,CAAC;QACH;MACF,CACF,CAAC;IACH,CAAC,CAAC,OAAOC,CAAC,EAAE;MACV,MAAMA,CAAC;IACT,CAAC,SAAS;MACR3C,oBAAoB,CAACkB,GAAG,CAAC0B,yBAAyB,CAChDd,0BACF,CAAC;IACH;EACF;AACF","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}