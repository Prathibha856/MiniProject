{"ast":null,"code":"import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/classPrivateFieldLooseKey\";\nimport { PerformanceEntry } from './PerformanceEntry';\nimport { warnNoNativePerformanceObserver } from './PerformanceObserver';\nimport NativePerformanceObserver from './specs/NativePerformanceObserver';\nvar _processingStart = _classPrivateFieldLooseKey(\"processingStart\");\nvar _processingEnd = _classPrivateFieldLooseKey(\"processingEnd\");\nvar _interactionId = _classPrivateFieldLooseKey(\"interactionId\");\nexport class PerformanceEventTiming extends PerformanceEntry {\n  constructor(init) {\n    super({\n      name: init.name,\n      entryType: 'event',\n      startTime: init.startTime ?? 0,\n      duration: init.duration ?? 0\n    });\n    Object.defineProperty(this, _processingStart, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _processingEnd, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _interactionId, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _processingStart)[_processingStart] = init.processingStart ?? 0;\n    _classPrivateFieldLooseBase(this, _processingEnd)[_processingEnd] = init.processingEnd ?? 0;\n    _classPrivateFieldLooseBase(this, _interactionId)[_interactionId] = init.interactionId ?? 0;\n  }\n  get processingStart() {\n    return _classPrivateFieldLooseBase(this, _processingStart)[_processingStart];\n  }\n  get processingEnd() {\n    return _classPrivateFieldLooseBase(this, _processingEnd)[_processingEnd];\n  }\n  get interactionId() {\n    return _classPrivateFieldLooseBase(this, _interactionId)[_interactionId];\n  }\n  toJSON() {\n    return Object.assign({}, super.toJSON(), {\n      processingStart: _classPrivateFieldLooseBase(this, _processingStart)[_processingStart],\n      processingEnd: _classPrivateFieldLooseBase(this, _processingEnd)[_processingEnd],\n      interactionId: _classPrivateFieldLooseBase(this, _interactionId)[_interactionId]\n    });\n  }\n}\nlet cachedEventCounts;\nfunction getCachedEventCounts() {\n  if (cachedEventCounts) {\n    return cachedEventCounts;\n  }\n  if (!NativePerformanceObserver) {\n    warnNoNativePerformanceObserver();\n    return new Map();\n  }\n  cachedEventCounts = new Map(NativePerformanceObserver.getEventCounts());\n  global.queueMicrotask(() => {\n    cachedEventCounts = null;\n  });\n  return cachedEventCounts ?? new Map();\n}\nexport class EventCounts {\n  get size() {\n    return getCachedEventCounts().size;\n  }\n  entries() {\n    return getCachedEventCounts().entries();\n  }\n  forEach(callback) {\n    return getCachedEventCounts().forEach(callback);\n  }\n  get(key) {\n    return getCachedEventCounts().get(key);\n  }\n  has(key) {\n    return getCachedEventCounts().has(key);\n  }\n  keys() {\n    return getCachedEventCounts().keys();\n  }\n  values() {\n    return getCachedEventCounts().values();\n  }\n}","map":{"version":3,"names":["PerformanceEntry","warnNoNativePerformanceObserver","NativePerformanceObserver","_processingStart","_classPrivateFieldLooseKey","_processingEnd","_interactionId","PerformanceEventTiming","constructor","init","name","entryType","startTime","duration","Object","defineProperty","writable","value","_classPrivateFieldLooseBase","processingStart","processingEnd","interactionId","toJSON","assign","cachedEventCounts","getCachedEventCounts","Map","getEventCounts","global","queueMicrotask","EventCounts","size","entries","forEach","callback","get","key","has","keys","values"],"sources":["F:/MiniProject/node_modules/react-native/src/private/webapis/performance/EventTiming.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict\n */\n\n// flowlint unsafe-getters-setters:off\n\nimport type {\n  DOMHighResTimeStamp,\n  PerformanceEntryJSON,\n} from './PerformanceEntry';\n\nimport {PerformanceEntry} from './PerformanceEntry';\nimport {warnNoNativePerformanceObserver} from './PerformanceObserver';\nimport NativePerformanceObserver from './specs/NativePerformanceObserver';\n\nexport type PerformanceEventTimingJSON = {\n  ...PerformanceEntryJSON,\n  processingStart: DOMHighResTimeStamp,\n  processingEnd: DOMHighResTimeStamp,\n  interactionId: number,\n  ...\n};\n\nexport class PerformanceEventTiming extends PerformanceEntry {\n  #processingStart: DOMHighResTimeStamp;\n  #processingEnd: DOMHighResTimeStamp;\n  #interactionId: number;\n\n  constructor(init: {\n    name: string,\n    startTime?: DOMHighResTimeStamp,\n    duration?: DOMHighResTimeStamp,\n    processingStart?: DOMHighResTimeStamp,\n    processingEnd?: DOMHighResTimeStamp,\n    interactionId?: number,\n  }) {\n    super({\n      name: init.name,\n      entryType: 'event',\n      startTime: init.startTime ?? 0,\n      duration: init.duration ?? 0,\n    });\n    this.#processingStart = init.processingStart ?? 0;\n    this.#processingEnd = init.processingEnd ?? 0;\n    this.#interactionId = init.interactionId ?? 0;\n  }\n\n  get processingStart(): DOMHighResTimeStamp {\n    return this.#processingStart;\n  }\n\n  get processingEnd(): DOMHighResTimeStamp {\n    return this.#processingEnd;\n  }\n\n  get interactionId(): number {\n    return this.#interactionId;\n  }\n\n  toJSON(): PerformanceEventTimingJSON {\n    return {\n      ...super.toJSON(),\n      processingStart: this.#processingStart,\n      processingEnd: this.#processingEnd,\n      interactionId: this.#interactionId,\n    };\n  }\n}\n\ntype EventCountsForEachCallbackType =\n  | (() => void)\n  | ((value: number) => void)\n  | ((value: number, key: string) => void)\n  | ((value: number, key: string, map: Map<string, number>) => void);\n\nlet cachedEventCounts: ?Map<string, number>;\n\nfunction getCachedEventCounts(): Map<string, number> {\n  if (cachedEventCounts) {\n    return cachedEventCounts;\n  }\n  if (!NativePerformanceObserver) {\n    warnNoNativePerformanceObserver();\n    return new Map();\n  }\n\n  cachedEventCounts = new Map<string, number>(\n    NativePerformanceObserver.getEventCounts(),\n  );\n  // $FlowFixMe[incompatible-call]\n  global.queueMicrotask(() => {\n    // To be consistent with the calls to the API from the same task,\n    // but also not to refetch the data from native too often,\n    // schedule to invalidate the cache later,\n    // after the current task is guaranteed to have finished.\n    cachedEventCounts = null;\n  });\n  return cachedEventCounts ?? new Map();\n}\n\n/**\n * Implementation of the EventCounts Web Performance API\n * corresponding to the standard in\n * https://www.w3.org/TR/event-timing/#eventcounts\n */\nexport class EventCounts {\n  get size(): number {\n    return getCachedEventCounts().size;\n  }\n\n  entries(): Iterator<[string, number]> {\n    return getCachedEventCounts().entries();\n  }\n\n  forEach(callback: EventCountsForEachCallbackType): void {\n    return getCachedEventCounts().forEach(callback);\n  }\n\n  get(key: string): ?number {\n    return getCachedEventCounts().get(key);\n  }\n\n  has(key: string): boolean {\n    return getCachedEventCounts().has(key);\n  }\n\n  keys(): Iterator<string> {\n    return getCachedEventCounts().keys();\n  }\n\n  values(): Iterator<number> {\n    return getCachedEventCounts().values();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}