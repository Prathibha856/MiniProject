{"ast":null,"code":"import * as LogBoxSymbolication from './LogBoxSymbolication';\nfunction convertComponentStateToStack(componentStack) {\n  return componentStack.map(frame => ({\n    column: frame?.location?.column,\n    file: frame.fileName,\n    lineNumber: frame?.location?.row,\n    methodName: frame.content,\n    collapse: false\n  }));\n}\nfunction convertStackToComponentStack(stack) {\n  const componentStack = [];\n  for (let i = 0; i < stack.length; i++) {\n    const frame = stack[i];\n    if (frame.lineNumber != null && frame.column != null) {\n      componentStack.push({\n        fileName: frame?.file || '',\n        location: {\n          row: frame.lineNumber,\n          column: frame.column\n        },\n        content: frame.methodName,\n        collapse: false\n      });\n    }\n  }\n  return componentStack;\n}\nclass LogBoxLog {\n  constructor(data) {\n    this.message = void 0;\n    this.type = void 0;\n    this.category = void 0;\n    this.componentStack = void 0;\n    this.componentStackType = void 0;\n    this.stack = void 0;\n    this.count = void 0;\n    this.level = void 0;\n    this.codeFrame = void 0;\n    this.isComponentError = void 0;\n    this.extraData = void 0;\n    this.symbolicated = {\n      error: null,\n      stack: null,\n      status: 'NONE'\n    };\n    this.symbolicatedComponentStack = {\n      error: null,\n      componentStack: null,\n      status: 'NONE'\n    };\n    this.onNotificationPress = void 0;\n    this.level = data.level;\n    this.type = data.type;\n    this.message = data.message;\n    this.stack = data.stack;\n    this.category = data.category;\n    this.componentStack = data.componentStack;\n    this.componentStackType = data.componentStackType || 'legacy';\n    this.codeFrame = data.codeFrame;\n    this.isComponentError = data.isComponentError;\n    this.extraData = data.extraData;\n    this.count = 1;\n    this.onNotificationPress = data.onNotificationPress;\n  }\n  incrementCount() {\n    this.count += 1;\n  }\n  getAvailableStack() {\n    return this.symbolicated.status === 'COMPLETE' ? this.symbolicated.stack : this.stack;\n  }\n  getAvailableComponentStack() {\n    if (this.componentStackType === 'legacy') {\n      return this.componentStack;\n    }\n    return this.symbolicatedComponentStack.status === 'COMPLETE' ? this.symbolicatedComponentStack.componentStack : this.componentStack;\n  }\n  retrySymbolicate(callback) {\n    if (this.symbolicated.status !== 'COMPLETE') {\n      LogBoxSymbolication.deleteStack(this.stack);\n      this.handleSymbolicate(callback);\n    }\n  }\n  symbolicate(callback) {\n    if (this.symbolicated.status === 'NONE') {\n      this.handleSymbolicate(callback);\n    }\n  }\n  handleSymbolicate(callback) {\n    if (this.symbolicated.status !== 'PENDING') {\n      this.updateStatus(null, null, null, callback);\n      LogBoxSymbolication.symbolicate(this.stack, this.extraData).then(data => {\n        this.updateStatus(null, data?.stack, data?.codeFrame, callback);\n      }, error => {\n        this.updateStatus(error, null, null, callback);\n      });\n      if (this.componentStack != null && this.componentStackType === 'stack') {\n        this.updateComponentStackStatus(null, null, null, callback);\n        const componentStackFrames = convertComponentStateToStack(this.componentStack);\n        LogBoxSymbolication.symbolicate(componentStackFrames, []).then(data => {\n          this.updateComponentStackStatus(null, convertStackToComponentStack(data.stack), null, callback);\n        }, error => {\n          this.updateComponentStackStatus(error, null, null, callback);\n        });\n      }\n    }\n  }\n  updateStatus(error, stack, codeFrame, callback) {\n    const lastStatus = this.symbolicated.status;\n    if (error != null) {\n      this.symbolicated = {\n        error,\n        stack: null,\n        status: 'FAILED'\n      };\n    } else if (stack != null) {\n      if (codeFrame) {\n        this.codeFrame = codeFrame;\n      }\n      this.symbolicated = {\n        error: null,\n        stack,\n        status: 'COMPLETE'\n      };\n    } else {\n      this.symbolicated = {\n        error: null,\n        stack: null,\n        status: 'PENDING'\n      };\n    }\n    if (callback && lastStatus !== this.symbolicated.status) {\n      callback(this.symbolicated.status);\n    }\n  }\n  updateComponentStackStatus(error, componentStack, codeFrame, callback) {\n    const lastStatus = this.symbolicatedComponentStack.status;\n    if (error != null) {\n      this.symbolicatedComponentStack = {\n        error,\n        componentStack: null,\n        status: 'FAILED'\n      };\n    } else if (componentStack != null) {\n      this.symbolicatedComponentStack = {\n        error: null,\n        componentStack,\n        status: 'COMPLETE'\n      };\n    } else {\n      this.symbolicatedComponentStack = {\n        error: null,\n        componentStack: null,\n        status: 'PENDING'\n      };\n    }\n    if (callback && lastStatus !== this.symbolicatedComponentStack.status) {\n      callback(this.symbolicatedComponentStack.status);\n    }\n  }\n}\nexport default LogBoxLog;","map":{"version":3,"names":["LogBoxSymbolication","convertComponentStateToStack","componentStack","map","frame","column","location","file","fileName","lineNumber","row","methodName","content","collapse","convertStackToComponentStack","stack","i","length","push","LogBoxLog","constructor","data","message","type","category","componentStackType","count","level","codeFrame","isComponentError","extraData","symbolicated","error","status","symbolicatedComponentStack","onNotificationPress","incrementCount","getAvailableStack","getAvailableComponentStack","retrySymbolicate","callback","deleteStack","handleSymbolicate","symbolicate","updateStatus","then","updateComponentStackStatus","componentStackFrames","lastStatus"],"sources":["F:/MiniProject/node_modules/react-native/Libraries/LogBox/Data/LogBoxLog.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nimport type {Stack} from './LogBoxSymbolication';\nimport type {\n  Category,\n  CodeFrame,\n  ComponentStack,\n  ComponentStackType,\n  Message,\n} from './parseLogBoxLog';\n\nimport * as LogBoxSymbolication from './LogBoxSymbolication';\n\ntype SymbolicationStatus = 'NONE' | 'PENDING' | 'COMPLETE' | 'FAILED';\n\nexport type LogLevel = 'warn' | 'error' | 'fatal' | 'syntax';\n\n// TODO: once component stacks are fully supported, we can refactor\n// ComponentStack to just be Stack and remove these conversions fns.\nfunction convertComponentStateToStack(componentStack: ComponentStack): Stack {\n  return componentStack.map(frame => ({\n    column: frame?.location?.column,\n    file: frame.fileName,\n    lineNumber: frame?.location?.row,\n    methodName: frame.content,\n    collapse: false,\n  }));\n}\n\nfunction convertStackToComponentStack(stack: Stack): ComponentStack {\n  const componentStack = [];\n  for (let i = 0; i < stack.length; i++) {\n    const frame = stack[i];\n    // NOTE: Skip stack frames missing location.\n    if (frame.lineNumber != null && frame.column != null) {\n      componentStack.push({\n        fileName: frame?.file || '',\n        location: {\n          row: frame.lineNumber,\n          column: frame.column,\n        },\n        content: frame.methodName,\n        collapse: false,\n      });\n    }\n  }\n  return componentStack;\n}\n\nexport type LogBoxLogData = $ReadOnly<{\n  level: LogLevel,\n  type?: ?string,\n  message: Message,\n  stack: Stack,\n  category: string,\n  componentStackType?: ComponentStackType,\n  componentStack: ComponentStack,\n  codeFrame?: ?CodeFrame,\n  isComponentError: boolean,\n  extraData?: mixed,\n  onNotificationPress?: ?() => void,\n}>;\n\nclass LogBoxLog {\n  message: Message;\n  type: ?string;\n  category: Category;\n  componentStack: ComponentStack;\n  componentStackType: ComponentStackType;\n  stack: Stack;\n  count: number;\n  level: LogLevel;\n  codeFrame: ?CodeFrame;\n  isComponentError: boolean;\n  extraData: mixed | void;\n  symbolicated:\n    | $ReadOnly<{|error: null, stack: null, status: 'NONE'|}>\n    | $ReadOnly<{|error: null, stack: null, status: 'PENDING'|}>\n    | $ReadOnly<{|error: null, stack: Stack, status: 'COMPLETE'|}>\n    | $ReadOnly<{|error: Error, stack: null, status: 'FAILED'|}> = {\n    error: null,\n    stack: null,\n    status: 'NONE',\n  };\n  symbolicatedComponentStack:\n    | $ReadOnly<{|error: null, componentStack: null, status: 'NONE'|}>\n    | $ReadOnly<{|error: null, componentStack: null, status: 'PENDING'|}>\n    | $ReadOnly<{|\n        error: null,\n        componentStack: ComponentStack,\n        status: 'COMPLETE',\n      |}>\n    | $ReadOnly<{|error: Error, componentStack: null, status: 'FAILED'|}> = {\n    error: null,\n    componentStack: null,\n    status: 'NONE',\n  };\n  onNotificationPress: ?() => void;\n\n  constructor(data: LogBoxLogData) {\n    this.level = data.level;\n    this.type = data.type;\n    this.message = data.message;\n    this.stack = data.stack;\n    this.category = data.category;\n    this.componentStack = data.componentStack;\n    this.componentStackType = data.componentStackType || 'legacy';\n    this.codeFrame = data.codeFrame;\n    this.isComponentError = data.isComponentError;\n    this.extraData = data.extraData;\n    this.count = 1;\n    this.onNotificationPress = data.onNotificationPress;\n  }\n\n  incrementCount(): void {\n    this.count += 1;\n  }\n\n  getAvailableStack(): Stack {\n    return this.symbolicated.status === 'COMPLETE'\n      ? this.symbolicated.stack\n      : this.stack;\n  }\n\n  getAvailableComponentStack(): ComponentStack {\n    if (this.componentStackType === 'legacy') {\n      return this.componentStack;\n    }\n    return this.symbolicatedComponentStack.status === 'COMPLETE'\n      ? this.symbolicatedComponentStack.componentStack\n      : this.componentStack;\n  }\n\n  retrySymbolicate(callback?: (status: SymbolicationStatus) => void): void {\n    if (this.symbolicated.status !== 'COMPLETE') {\n      LogBoxSymbolication.deleteStack(this.stack);\n      this.handleSymbolicate(callback);\n    }\n  }\n\n  symbolicate(callback?: (status: SymbolicationStatus) => void): void {\n    if (this.symbolicated.status === 'NONE') {\n      this.handleSymbolicate(callback);\n    }\n  }\n\n  handleSymbolicate(callback?: (status: SymbolicationStatus) => void): void {\n    if (this.symbolicated.status !== 'PENDING') {\n      this.updateStatus(null, null, null, callback);\n      LogBoxSymbolication.symbolicate(this.stack, this.extraData).then(\n        data => {\n          this.updateStatus(null, data?.stack, data?.codeFrame, callback);\n        },\n        error => {\n          this.updateStatus(error, null, null, callback);\n        },\n      );\n      if (this.componentStack != null && this.componentStackType === 'stack') {\n        this.updateComponentStackStatus(null, null, null, callback);\n        const componentStackFrames = convertComponentStateToStack(\n          this.componentStack,\n        );\n        LogBoxSymbolication.symbolicate(componentStackFrames, []).then(\n          data => {\n            this.updateComponentStackStatus(\n              null,\n              convertStackToComponentStack(data.stack),\n              null,\n              callback,\n            );\n          },\n          error => {\n            this.updateComponentStackStatus(error, null, null, callback);\n          },\n        );\n      }\n    }\n  }\n\n  updateStatus(\n    error: ?Error,\n    stack: ?Stack,\n    codeFrame: ?CodeFrame,\n    callback?: (status: SymbolicationStatus) => void,\n  ): void {\n    const lastStatus = this.symbolicated.status;\n    if (error != null) {\n      this.symbolicated = {\n        error,\n        stack: null,\n        status: 'FAILED',\n      };\n    } else if (stack != null) {\n      if (codeFrame) {\n        this.codeFrame = codeFrame;\n      }\n\n      this.symbolicated = {\n        error: null,\n        stack,\n        status: 'COMPLETE',\n      };\n    } else {\n      this.symbolicated = {\n        error: null,\n        stack: null,\n        status: 'PENDING',\n      };\n    }\n\n    if (callback && lastStatus !== this.symbolicated.status) {\n      callback(this.symbolicated.status);\n    }\n  }\n\n  updateComponentStackStatus(\n    error: ?Error,\n    componentStack: ?ComponentStack,\n    codeFrame: ?CodeFrame,\n    callback?: (status: SymbolicationStatus) => void,\n  ): void {\n    const lastStatus = this.symbolicatedComponentStack.status;\n    if (error != null) {\n      this.symbolicatedComponentStack = {\n        error,\n        componentStack: null,\n        status: 'FAILED',\n      };\n    } else if (componentStack != null) {\n      this.symbolicatedComponentStack = {\n        error: null,\n        componentStack,\n        status: 'COMPLETE',\n      };\n    } else {\n      this.symbolicatedComponentStack = {\n        error: null,\n        componentStack: null,\n        status: 'PENDING',\n      };\n    }\n\n    if (callback && lastStatus !== this.symbolicatedComponentStack.status) {\n      callback(this.symbolicatedComponentStack.status);\n    }\n  }\n}\n\nexport default LogBoxLog;\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}