{"ast":null,"code":"import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/classPrivateFieldLooseKey\";\nimport warnOnce from '../../../../Libraries/Utilities/warnOnce';\nimport { PerformanceEventTiming } from './EventTiming';\nimport { PerformanceEntry } from './PerformanceEntry';\nimport { performanceEntryTypeToRaw, rawToPerformanceEntry, rawToPerformanceEntryType } from './RawPerformanceEntry';\nimport NativePerformanceObserver from './specs/NativePerformanceObserver';\nexport { PerformanceEntry } from './PerformanceEntry';\nvar _entries = _classPrivateFieldLooseKey(\"entries\");\nexport class PerformanceObserverEntryList {\n  constructor(entries) {\n    Object.defineProperty(this, _entries, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _entries)[_entries] = entries;\n  }\n  getEntries() {\n    return _classPrivateFieldLooseBase(this, _entries)[_entries];\n  }\n  getEntriesByType(type) {\n    return _classPrivateFieldLooseBase(this, _entries)[_entries].filter(entry => entry.entryType === type);\n  }\n  getEntriesByName(name, type) {\n    if (type === undefined) {\n      return _classPrivateFieldLooseBase(this, _entries)[_entries].filter(entry => entry.name === name);\n    } else {\n      return _classPrivateFieldLooseBase(this, _entries)[_entries].filter(entry => entry.name === name && entry.entryType === type);\n    }\n  }\n}\nconst observerCountPerEntryType = new Map();\nconst registeredObservers = new Map();\nlet isOnPerformanceEntryCallbackSet = false;\nconst onPerformanceEntry = () => {\n  if (!NativePerformanceObserver) {\n    return;\n  }\n  const entryResult = NativePerformanceObserver.popPendingEntries();\n  const rawEntries = entryResult?.entries ?? [];\n  const droppedEntriesCount = entryResult?.droppedEntriesCount;\n  if (rawEntries.length === 0) {\n    return;\n  }\n  const entries = rawEntries.map(rawToPerformanceEntry);\n  for (const [observer, observerConfig] of registeredObservers.entries()) {\n    const entriesForObserver = entries.filter(entry => {\n      if (!observerConfig.entryTypes.has(entry.entryType)) {\n        return false;\n      }\n      if (entry.entryType === 'event' && observerConfig.durationThreshold != null) {\n        return entry.duration >= observerConfig.durationThreshold;\n      }\n      return true;\n    });\n    if (entriesForObserver.length !== 0) {\n      try {\n        observerConfig.callback(new PerformanceObserverEntryList(entriesForObserver), observer, droppedEntriesCount);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  }\n};\nexport function warnNoNativePerformanceObserver() {\n  warnOnce('missing-native-performance-observer', 'Missing native implementation of PerformanceObserver');\n}\nfunction applyDurationThresholds() {\n  const durationThresholds = Array.from(registeredObservers.values()).map(observerConfig => observerConfig.durationThreshold).filter(Boolean);\n  return Math.min(...durationThresholds);\n}\nfunction getSupportedPerformanceEntryTypes() {\n  if (!NativePerformanceObserver) {\n    return Object.freeze([]);\n  }\n  if (!NativePerformanceObserver.getSupportedPerformanceEntryTypes) {\n    return Object.freeze(['mark', 'measure', 'event']);\n  }\n  return Object.freeze(NativePerformanceObserver.getSupportedPerformanceEntryTypes().map(rawToPerformanceEntryType));\n}\nvar _callback = _classPrivateFieldLooseKey(\"callback\");\nvar _type = _classPrivateFieldLooseKey(\"type\");\nvar _validateObserveOptions = _classPrivateFieldLooseKey(\"validateObserveOptions\");\nexport class PerformanceObserver {\n  constructor(callback) {\n    Object.defineProperty(this, _validateObserveOptions, {\n      value: _validateObserveOptions2\n    });\n    Object.defineProperty(this, _callback, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _type, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _callback)[_callback] = callback;\n  }\n  observe(options) {\n    if (!NativePerformanceObserver) {\n      warnNoNativePerformanceObserver();\n      return;\n    }\n    _classPrivateFieldLooseBase(this, _validateObserveOptions)[_validateObserveOptions](options);\n    let requestedEntryTypes;\n    if (options.entryTypes) {\n      _classPrivateFieldLooseBase(this, _type)[_type] = 'multiple';\n      requestedEntryTypes = new Set(options.entryTypes);\n    } else {\n      _classPrivateFieldLooseBase(this, _type)[_type] = 'single';\n      requestedEntryTypes = new Set([options.type]);\n    }\n    const currentEntryTypes = registeredObservers.get(this)?.entryTypes;\n    const nextEntryTypes = currentEntryTypes ? union(requestedEntryTypes, currentEntryTypes) : requestedEntryTypes;\n    if (currentEntryTypes && currentEntryTypes.size === nextEntryTypes.size) {\n      return;\n    }\n    registeredObservers.set(this, {\n      callback: _classPrivateFieldLooseBase(this, _callback)[_callback],\n      durationThreshold: options.type === 'event' ? options.durationThreshold : undefined,\n      entryTypes: nextEntryTypes\n    });\n    if (!isOnPerformanceEntryCallbackSet) {\n      NativePerformanceObserver.setOnPerformanceEntryCallback(onPerformanceEntry);\n      isOnPerformanceEntryCallbackSet = true;\n    }\n    const newEntryTypes = currentEntryTypes ? difference(new Set(requestedEntryTypes.keys()), new Set(currentEntryTypes.keys())) : new Set(requestedEntryTypes.keys());\n    for (const type of newEntryTypes) {\n      if (!observerCountPerEntryType.has(type)) {\n        const rawType = performanceEntryTypeToRaw(type);\n        NativePerformanceObserver.startReporting(rawType);\n      }\n      observerCountPerEntryType.set(type, (observerCountPerEntryType.get(type) ?? 0) + 1);\n    }\n    applyDurationThresholds();\n  }\n  disconnect() {\n    if (!NativePerformanceObserver) {\n      warnNoNativePerformanceObserver();\n      return;\n    }\n    const observerConfig = registeredObservers.get(this);\n    if (!observerConfig) {\n      return;\n    }\n    for (const type of observerConfig.entryTypes.keys()) {\n      const numberOfObserversForThisType = observerCountPerEntryType.get(type) ?? 0;\n      if (numberOfObserversForThisType === 1) {\n        observerCountPerEntryType.delete(type);\n        NativePerformanceObserver.stopReporting(performanceEntryTypeToRaw(type));\n      } else if (numberOfObserversForThisType !== 0) {\n        observerCountPerEntryType.set(type, numberOfObserversForThisType - 1);\n      }\n    }\n    registeredObservers.delete(this);\n    if (registeredObservers.size === 0) {\n      NativePerformanceObserver.setOnPerformanceEntryCallback(undefined);\n      isOnPerformanceEntryCallbackSet = false;\n    }\n    applyDurationThresholds();\n  }\n}\nfunction _validateObserveOptions2(options) {\n  const {\n    type,\n    entryTypes,\n    durationThreshold\n  } = options;\n  if (!type && !entryTypes) {\n    throw new TypeError(\"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must not include both entryTypes and type arguments.\");\n  }\n  if (entryTypes && type) {\n    throw new TypeError(\"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must include either entryTypes or type arguments.\");\n  }\n  if (_classPrivateFieldLooseBase(this, _type)[_type] === 'multiple' && type) {\n    throw new Error(\"Failed to execute 'observe' on 'PerformanceObserver': This observer has performed observe({entryTypes:...}, therefore it cannot perform observe({type:...})\");\n  }\n  if (_classPrivateFieldLooseBase(this, _type)[_type] === 'single' && entryTypes) {\n    throw new Error(\"Failed to execute 'observe' on 'PerformanceObserver': This PerformanceObserver has performed observe({type:...}, therefore it cannot perform observe({entryTypes:...})\");\n  }\n  if (entryTypes && durationThreshold !== undefined) {\n    throw new TypeError(\"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must not include both entryTypes and durationThreshold arguments.\");\n  }\n}\nPerformanceObserver.supportedEntryTypes = getSupportedPerformanceEntryTypes();\nfunction union(a, b) {\n  return new Set([...a, ...b]);\n}\nfunction difference(a, b) {\n  return new Set([...a].filter(x => !b.has(x)));\n}\nexport { PerformanceEventTiming };","map":{"version":3,"names":["warnOnce","PerformanceEventTiming","PerformanceEntry","performanceEntryTypeToRaw","rawToPerformanceEntry","rawToPerformanceEntryType","NativePerformanceObserver","_entries","_classPrivateFieldLooseKey","PerformanceObserverEntryList","constructor","entries","Object","defineProperty","writable","value","_classPrivateFieldLooseBase","getEntries","getEntriesByType","type","filter","entry","entryType","getEntriesByName","name","undefined","observerCountPerEntryType","Map","registeredObservers","isOnPerformanceEntryCallbackSet","onPerformanceEntry","entryResult","popPendingEntries","rawEntries","droppedEntriesCount","length","map","observer","observerConfig","entriesForObserver","entryTypes","has","durationThreshold","duration","callback","error","console","warnNoNativePerformanceObserver","applyDurationThresholds","durationThresholds","Array","from","values","Boolean","Math","min","getSupportedPerformanceEntryTypes","freeze","_callback","_type","_validateObserveOptions","PerformanceObserver","_validateObserveOptions2","observe","options","requestedEntryTypes","Set","currentEntryTypes","get","nextEntryTypes","union","size","set","setOnPerformanceEntryCallback","newEntryTypes","difference","keys","rawType","startReporting","disconnect","numberOfObserversForThisType","delete","stopReporting","TypeError","Error","supportedEntryTypes","a","b","x"],"sources":["F:/MiniProject/node_modules/react-native/src/private/webapis/performance/PerformanceObserver.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict\n */\n\nimport type {\n  DOMHighResTimeStamp,\n  PerformanceEntryType,\n} from './PerformanceEntry';\n\nimport warnOnce from '../../../../Libraries/Utilities/warnOnce';\nimport {PerformanceEventTiming} from './EventTiming';\nimport {PerformanceEntry} from './PerformanceEntry';\nimport {\n  performanceEntryTypeToRaw,\n  rawToPerformanceEntry,\n  rawToPerformanceEntryType,\n} from './RawPerformanceEntry';\nimport NativePerformanceObserver from './specs/NativePerformanceObserver';\n\nexport type PerformanceEntryList = $ReadOnlyArray<PerformanceEntry>;\n\nexport {PerformanceEntry} from './PerformanceEntry';\n\nexport class PerformanceObserverEntryList {\n  #entries: PerformanceEntryList;\n\n  constructor(entries: PerformanceEntryList) {\n    this.#entries = entries;\n  }\n\n  getEntries(): PerformanceEntryList {\n    return this.#entries;\n  }\n\n  getEntriesByType(type: PerformanceEntryType): PerformanceEntryList {\n    return this.#entries.filter(entry => entry.entryType === type);\n  }\n\n  getEntriesByName(\n    name: string,\n    type?: PerformanceEntryType,\n  ): PerformanceEntryList {\n    if (type === undefined) {\n      return this.#entries.filter(entry => entry.name === name);\n    } else {\n      return this.#entries.filter(\n        entry => entry.name === name && entry.entryType === type,\n      );\n    }\n  }\n}\n\nexport type PerformanceObserverCallback = (\n  list: PerformanceObserverEntryList,\n  observer: PerformanceObserver,\n  // The number of buffered entries which got dropped from the buffer due to the buffer being full:\n  droppedEntryCount?: number,\n) => void;\n\nexport type PerformanceObserverInit =\n  | {\n      entryTypes: Array<PerformanceEntryType>,\n    }\n  | {\n      type: PerformanceEntryType,\n      durationThreshold?: DOMHighResTimeStamp,\n    };\n\ntype PerformanceObserverConfig = {|\n  callback: PerformanceObserverCallback,\n  entryTypes: $ReadOnlySet<PerformanceEntryType>,\n  durationThreshold: ?number,\n|};\n\nconst observerCountPerEntryType: Map<PerformanceEntryType, number> = new Map();\nconst registeredObservers: Map<PerformanceObserver, PerformanceObserverConfig> =\n  new Map();\nlet isOnPerformanceEntryCallbackSet: boolean = false;\n\n// This is a callback that gets scheduled and periodically called from the native side\nconst onPerformanceEntry = () => {\n  if (!NativePerformanceObserver) {\n    return;\n  }\n  const entryResult = NativePerformanceObserver.popPendingEntries();\n  const rawEntries = entryResult?.entries ?? [];\n  const droppedEntriesCount = entryResult?.droppedEntriesCount;\n  if (rawEntries.length === 0) {\n    return;\n  }\n  const entries = rawEntries.map(rawToPerformanceEntry);\n  for (const [observer, observerConfig] of registeredObservers.entries()) {\n    const entriesForObserver: PerformanceEntryList = entries.filter(entry => {\n      if (!observerConfig.entryTypes.has(entry.entryType)) {\n        return false;\n      }\n\n      if (\n        entry.entryType === 'event' &&\n        observerConfig.durationThreshold != null\n      ) {\n        return entry.duration >= observerConfig.durationThreshold;\n      }\n\n      return true;\n    });\n    if (entriesForObserver.length !== 0) {\n      try {\n        observerConfig.callback(\n          new PerformanceObserverEntryList(entriesForObserver),\n          observer,\n          droppedEntriesCount,\n        );\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  }\n};\n\nexport function warnNoNativePerformanceObserver() {\n  warnOnce(\n    'missing-native-performance-observer',\n    'Missing native implementation of PerformanceObserver',\n  );\n}\n\nfunction applyDurationThresholds() {\n  const durationThresholds = Array.from(registeredObservers.values())\n    .map(observerConfig => observerConfig.durationThreshold)\n    .filter(Boolean);\n\n  return Math.min(...durationThresholds);\n}\n\nfunction getSupportedPerformanceEntryTypes(): $ReadOnlyArray<PerformanceEntryType> {\n  if (!NativePerformanceObserver) {\n    return Object.freeze([]);\n  }\n  if (!NativePerformanceObserver.getSupportedPerformanceEntryTypes) {\n    // fallback if getSupportedPerformanceEntryTypes is not defined on native side\n    return Object.freeze(['mark', 'measure', 'event']);\n  }\n  return Object.freeze(\n    NativePerformanceObserver.getSupportedPerformanceEntryTypes().map(\n      rawToPerformanceEntryType,\n    ),\n  );\n}\n\n/**\n * Implementation of the PerformanceObserver interface for RN,\n * corresponding to the standard in https://www.w3.org/TR/performance-timeline/\n *\n * @example\n * const observer = new PerformanceObserver((list, _observer) => {\n *   const entries = list.getEntries();\n *   entries.forEach(entry => {\n *     reportEvent({\n *       eventName: entry.name,\n *       startTime: entry.startTime,\n *       endTime: entry.startTime + entry.duration,\n *       processingStart: entry.processingStart,\n *       processingEnd: entry.processingEnd,\n *       interactionId: entry.interactionId,\n *     });\n *   });\n * });\n * observer.observe({ type: \"event\" });\n */\nexport class PerformanceObserver {\n  #callback: PerformanceObserverCallback;\n  #type: 'single' | 'multiple' | void;\n\n  constructor(callback: PerformanceObserverCallback) {\n    this.#callback = callback;\n  }\n\n  observe(options: PerformanceObserverInit): void {\n    if (!NativePerformanceObserver) {\n      warnNoNativePerformanceObserver();\n      return;\n    }\n\n    this.#validateObserveOptions(options);\n\n    let requestedEntryTypes;\n\n    if (options.entryTypes) {\n      this.#type = 'multiple';\n      requestedEntryTypes = new Set(options.entryTypes);\n    } else {\n      this.#type = 'single';\n      requestedEntryTypes = new Set([options.type]);\n    }\n\n    // The same observer may receive multiple calls to \"observe\", so we need\n    // to check what is new on this call vs. previous ones.\n    const currentEntryTypes = registeredObservers.get(this)?.entryTypes;\n    const nextEntryTypes = currentEntryTypes\n      ? union(requestedEntryTypes, currentEntryTypes)\n      : requestedEntryTypes;\n\n    // This `observe` call is a no-op because there are no new things to observe.\n    if (currentEntryTypes && currentEntryTypes.size === nextEntryTypes.size) {\n      return;\n    }\n\n    registeredObservers.set(this, {\n      callback: this.#callback,\n      durationThreshold:\n        options.type === 'event' ? options.durationThreshold : undefined,\n      entryTypes: nextEntryTypes,\n    });\n\n    if (!isOnPerformanceEntryCallbackSet) {\n      NativePerformanceObserver.setOnPerformanceEntryCallback(\n        onPerformanceEntry,\n      );\n      isOnPerformanceEntryCallbackSet = true;\n    }\n\n    // We only need to start listenening to new entry types being observed in\n    // this observer.\n    const newEntryTypes = currentEntryTypes\n      ? difference(\n          new Set(requestedEntryTypes.keys()),\n          new Set(currentEntryTypes.keys()),\n        )\n      : new Set(requestedEntryTypes.keys());\n    for (const type of newEntryTypes) {\n      if (!observerCountPerEntryType.has(type)) {\n        const rawType = performanceEntryTypeToRaw(type);\n        NativePerformanceObserver.startReporting(rawType);\n      }\n      observerCountPerEntryType.set(\n        type,\n        (observerCountPerEntryType.get(type) ?? 0) + 1,\n      );\n    }\n    applyDurationThresholds();\n  }\n\n  disconnect(): void {\n    if (!NativePerformanceObserver) {\n      warnNoNativePerformanceObserver();\n      return;\n    }\n\n    const observerConfig = registeredObservers.get(this);\n    if (!observerConfig) {\n      return;\n    }\n\n    // Disconnect this observer\n    for (const type of observerConfig.entryTypes.keys()) {\n      const numberOfObserversForThisType =\n        observerCountPerEntryType.get(type) ?? 0;\n      if (numberOfObserversForThisType === 1) {\n        observerCountPerEntryType.delete(type);\n        NativePerformanceObserver.stopReporting(\n          performanceEntryTypeToRaw(type),\n        );\n      } else if (numberOfObserversForThisType !== 0) {\n        observerCountPerEntryType.set(type, numberOfObserversForThisType - 1);\n      }\n    }\n\n    // Disconnect all observers if this was the last one\n    registeredObservers.delete(this);\n    if (registeredObservers.size === 0) {\n      NativePerformanceObserver.setOnPerformanceEntryCallback(undefined);\n      isOnPerformanceEntryCallbackSet = false;\n    }\n\n    applyDurationThresholds();\n  }\n\n  #validateObserveOptions(options: PerformanceObserverInit): void {\n    const {type, entryTypes, durationThreshold} = options;\n\n    if (!type && !entryTypes) {\n      throw new TypeError(\n        \"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must not include both entryTypes and type arguments.\",\n      );\n    }\n\n    if (entryTypes && type) {\n      throw new TypeError(\n        \"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must include either entryTypes or type arguments.\",\n      );\n    }\n\n    if (this.#type === 'multiple' && type) {\n      throw new Error(\n        \"Failed to execute 'observe' on 'PerformanceObserver': This observer has performed observe({entryTypes:...}, therefore it cannot perform observe({type:...})\",\n      );\n    }\n\n    if (this.#type === 'single' && entryTypes) {\n      throw new Error(\n        \"Failed to execute 'observe' on 'PerformanceObserver': This PerformanceObserver has performed observe({type:...}, therefore it cannot perform observe({entryTypes:...})\",\n      );\n    }\n\n    if (entryTypes && durationThreshold !== undefined) {\n      throw new TypeError(\n        \"Failed to execute 'observe' on 'PerformanceObserver': An observe() call must not include both entryTypes and durationThreshold arguments.\",\n      );\n    }\n  }\n\n  static supportedEntryTypes: $ReadOnlyArray<PerformanceEntryType> =\n    getSupportedPerformanceEntryTypes();\n}\n\nfunction union<T>(a: $ReadOnlySet<T>, b: $ReadOnlySet<T>): Set<T> {\n  return new Set([...a, ...b]);\n}\n\nfunction difference<T>(a: $ReadOnlySet<T>, b: $ReadOnlySet<T>): Set<T> {\n  return new Set([...a].filter(x => !b.has(x)));\n}\n\nexport {PerformanceEventTiming};\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}